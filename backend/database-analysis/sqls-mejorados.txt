# SQLs Mejorados para Database Analysis - Post Phase 2
# Fecha: 2025-10-12
# Cambios: Scripts mejorados para documentar los 7 nuevos performance indexes

## 1. CURRENT_TABLES.json (SIN CAMBIOS - OK)

SELECT
    t.table_name,
    c.column_name,
    c.data_type,
    c.character_maximum_length,
    c.is_nullable,
    c.column_default,
    c.ordinal_position
FROM information_schema.tables t
JOIN information_schema.columns c ON t.table_name = c.table_name
WHERE t.table_schema = 'public'
    AND t.table_type = 'BASE TABLE'
ORDER BY t.table_name, c.ordinal_position;

---

## 2. CURRENT_FOREIGN_KEYS.json (SIN CAMBIOS - OK)

SELECT
    tc.constraint_name,
    tc.table_name,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name,
    rc.update_rule,
    rc.delete_rule
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu
    ON ccu.constraint_name = tc.constraint_name
JOIN information_schema.referential_constraints rc
    ON tc.constraint_name = rc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
    AND tc.table_schema = 'public'
ORDER BY tc.table_name, tc.constraint_name;

---

## 3. CURRENT_INDEXES.json (MEJORADO - MÁS INFO)

-- Script mejorado para incluir más información sobre indexes
SELECT
    pi.schemaname,
    pi.tablename,
    pi.indexname,
    pi.indexdef,
    CASE WHEN pi.indexdef LIKE '%UNIQUE%' THEN true ELSE false END as is_unique,
    CASE WHEN pi.indexdef LIKE '%CONCURRENTLY%' THEN true ELSE false END as created_concurrently,
    CASE WHEN pi.indexdef LIKE '%btree%' THEN 'btree'
         WHEN pi.indexdef LIKE '%hash%' THEN 'hash'
         WHEN pi.indexdef LIKE '%gin%' THEN 'gin'
         WHEN pi.indexdef LIKE '%gist%' THEN 'gist'
         ELSE 'other' END as index_type,
    pg_size_pretty(pg_relation_size(psi.indexrelid)) as index_size,
    COALESCE(psi.idx_scan, 0) as times_used,
    COALESCE(psi.idx_tup_read, 0) as tuples_read,
    COALESCE(psi.idx_tup_fetch, 0) as tuples_fetched
FROM pg_indexes pi
LEFT JOIN pg_stat_user_indexes psi ON pi.indexname = psi.indexrelname AND pi.schemaname = psi.schemaname
WHERE pi.schemaname = 'public'
ORDER BY pi.tablename, pi.indexname;

-- Nota: Este query mejorado muestra:
-- - Si el index fue creado CONCURRENTLY (como los 7 nuevos)
-- - Tamaño del index en disco
-- - Estadísticas de uso (times_used, tuples_read, tuples_fetched)
-- - Útil para monitorear efectividad de los nuevos indexes

---

## 4. CURRENT_ENUMS.json (SIN CAMBIOS - OK)

SELECT
    t.typname as enum_name,
    array_agg(e.enumlabel ORDER BY e.enumsortorder) as enum_values
FROM pg_type t
JOIN pg_enum e ON t.oid = e.enumtypid
JOIN pg_namespace n ON n.oid = t.typnamespace
WHERE n.nspname = 'public'
GROUP BY t.typname
ORDER BY t.typname;

---

## 5. CURRENT_CONSTRAINTS.json (SIN CAMBIOS - OK)

SELECT
    tc.constraint_name,
    tc.table_name,
    tc.constraint_type,
    STRING_AGG(kcu.column_name, ', ' ORDER BY kcu.ordinal_position) as column_names,
    cc.check_clause
FROM information_schema.table_constraints tc
LEFT JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
LEFT JOIN information_schema.check_constraints cc
    ON tc.constraint_name = cc.constraint_name
WHERE tc.table_schema = 'public'
    AND tc.constraint_type IN ('PRIMARY KEY', 'UNIQUE', 'CHECK')
GROUP BY tc.constraint_name, tc.table_name, tc.constraint_type, cc.check_clause
ORDER BY tc.table_name, tc.constraint_type;

---

## 6. DATABASE_STATS.json (MEJORADO - MÁS CONTEXTO)

-- Script mejorado para incluir estadísticas más útiles
SELECT
    ps.schemaname,
    ps.tablename,
    ps.attname as column_name,
    ps.n_distinct,
    ps.correlation,
    ps.null_frac,
    ps.avg_width,
    ps.most_common_vals::text as most_common_vals_sample,
    ps.histogram_bounds::text as histogram_sample
FROM pg_stats ps
WHERE ps.schemaname = 'public'
ORDER BY ps.tablename, ps.attname;

-- Agregado:
-- - null_frac: Porcentaje de valores NULL (importante para optimización)
-- - avg_width: Tamaño promedio en bytes (útil para calcular memoria)
-- - histogram_bounds: Sample de distribución de datos

---

## 7. COLUMN_STATISTICS.json (SIN CAMBIOS - OK)

SELECT
    table_schema,
    table_name,
    column_name,
    data_type,
    is_nullable,
    column_default
FROM information_schema.columns
WHERE table_schema = 'public'
ORDER BY table_name, ordinal_position;

---

## 8. REGISTROS_ESTIMADOS.json (MEJORADO - MÁS ÚTIL)

-- Script mejorado con más estadísticas de actividad
SELECT
    psut.schemaname,
    psut.relname as tablename,
    COALESCE(psut.n_tup_ins, 0) as total_inserts,
    COALESCE(psut.n_tup_upd, 0) as total_updates,
    COALESCE(psut.n_tup_del, 0) as total_deletes,
    COALESCE(psut.n_live_tup, 0) as current_rows,
    COALESCE(psut.n_dead_tup, 0) as dead_rows,
    ROUND((psut.n_dead_tup::numeric / NULLIF(psut.n_live_tup, 0)) * 100, 2) as dead_row_percentage,
    COALESCE(psut.seq_scan, 0) as sequential_scans,
    COALESCE(psut.seq_tup_read, 0) as sequential_tuples_read,
    COALESCE(psut.idx_scan, 0) as index_scans,
    COALESCE(psut.idx_tup_fetch, 0) as index_tuples_fetched,
    CASE
        WHEN COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0) > 0
        THEN ROUND((psut.idx_scan::numeric / (psut.seq_scan + psut.idx_scan)) * 100, 2)
        ELSE 0
    END as index_scan_percentage,
    psut.last_vacuum,
    psut.last_autovacuum,
    psut.last_analyze,
    psut.last_autoanalyze
FROM pg_stat_user_tables psut
WHERE psut.schemaname = 'public'
ORDER BY psut.relname;

-- Agregado:
-- - dead_row_percentage: % de filas muertas (indica necesidad de VACUUM)
-- - sequential_scans vs index_scans: Ratio de uso de indexes
-- - index_scan_percentage: % de queries que usan indexes (meta: >90%)

---

## 9. TABLE_SIZES.json (MEJORADO - MÁS DETALLE)

-- Script mejorado con más información de tamaño
SELECT
    pt.schemaname,
    pt.tablename,
    pg_size_pretty(pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename))) as total_size,
    pg_size_pretty(pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename))) as table_size,
    pg_size_pretty(pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) - pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename))) as indexes_size,
    ROUND(
        (pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) - pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)))::numeric /
        NULLIF(pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)), 0) * 100,
        2
    ) as index_to_table_ratio_percentage,
    pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) as total_bytes
FROM pg_tables pt
WHERE pt.schemaname = 'public'
ORDER BY pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) DESC;

-- Agregado:
-- - indexes_size: Tamaño total de todos los indexes de la tabla
-- - index_to_table_ratio: Ratio de tamaño indexes vs table (útil para optimización)
-- - total_bytes: Tamaño en bytes para cálculos programáticos

---

## 10. FREQUENT_UPDATES.json (SIN CAMBIOS - OK, pero context-specific)

SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    most_common_vals
FROM pg_stats
WHERE tablename = 'users'
ORDER BY attname;

-- Nota: Este query es específico para 'users' table
-- Si quieres generalizarlo para todas las tablas:

-- ALTERNATIVE: FREQUENT_UPDATES_ALL_TABLES.json
SELECT
    ps.schemaname,
    ps.tablename,
    ps.attname,
    ps.n_distinct,
    ps.most_common_vals::text as common_values_sample,
    ps.correlation
FROM pg_stats ps
WHERE ps.schemaname = 'public'
ORDER BY ps.tablename, ps.attname;

---

## NUEVO: 11. INDEX_USAGE_ANALYSIS.json (AGREGADO)

-- Nuevo script para analizar efectividad de los 7 nuevos indexes
SELECT
    psi.schemaname,
    psi.relname as tablename,
    psi.indexrelname as indexname,
    COALESCE(psi.idx_scan, 0) as times_used,
    COALESCE(psi.idx_tup_read, 0) as tuples_read,
    COALESCE(psi.idx_tup_fetch, 0) as tuples_fetched,
    pg_size_pretty(pg_relation_size(psi.indexrelid)) as index_size,
    CASE
        WHEN COALESCE(psi.idx_scan, 0) = 0 THEN 'UNUSED'
        WHEN psi.idx_scan < 100 THEN 'LOW_USAGE'
        WHEN psi.idx_scan < 1000 THEN 'MEDIUM_USAGE'
        ELSE 'HIGH_USAGE'
    END as usage_category,
    ROUND(
        CASE
            WHEN COALESCE(psi.idx_tup_read, 0) > 0
            THEN (psi.idx_tup_fetch::numeric / psi.idx_tup_read) * 100
            ELSE 0
        END,
        2
    ) as fetch_efficiency_percentage
FROM pg_stat_user_indexes psi
WHERE psi.schemaname = 'public'
ORDER BY psi.idx_scan DESC NULLS LAST;

-- Este query es CRÍTICO para Phase 3:
-- - Muestra cuántas veces se usó cada index
-- - Identifica indexes no usados (candidatos para eliminar)
-- - Calcula eficiencia de fetch (meta: >80%)
-- - Los 7 nuevos indexes deberían aparecer aquí

---

## NUEVO: 12. QUERY_PERFORMANCE_BASELINE.json (AGREGADO)

-- Nuevo script para establecer baseline de performance post-Phase 2
SELECT
    psut.schemaname,
    psut.relname as tablename,
    COALESCE(psut.seq_scan, 0) as sequential_scans,
    COALESCE(psut.seq_tup_read, 0) as seq_tuples_read,
    COALESCE(psut.idx_scan, 0) as index_scans,
    COALESCE(psut.idx_tup_fetch, 0) as idx_tuples_fetched,
    COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0) as total_modifications,
    COALESCE(psut.n_live_tup, 0) as current_rows,
    CASE
        WHEN COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0) > 0
        THEN ROUND((psut.idx_scan::numeric / (psut.seq_scan + psut.idx_scan)) * 100, 2)
        ELSE 0
    END as index_usage_percentage,
    CASE
        WHEN COALESCE(psut.seq_scan, 0) > COALESCE(psut.idx_scan, 0) THEN 'ADD_MORE_INDEXES'
        WHEN COALESCE(psut.idx_scan, 0) > COALESCE(psut.seq_scan, 0) * 10 THEN 'WELL_INDEXED'
        ELSE 'MODERATE_INDEXING'
    END as indexing_health
FROM pg_stat_user_tables psut
WHERE psut.schemaname = 'public'
ORDER BY psut.relname;

-- Este query establece un baseline de performance:
-- - Compara sequential scans vs index scans
-- - Meta: index_usage_percentage > 90%
-- - Útil para comparar antes/después de Redis (Phase 3)

---

## NUEVO: 13. CACHE_CANDIDATES.json (AGREGADO)

-- Nuevo script para identificar tablas candidatas para caching
SELECT
    psut.schemaname,
    psut.relname as tablename,
    COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0) as total_reads,
    COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0) as total_writes,
    CASE
        WHEN (COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0)) > 0
        THEN ROUND(((COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0))::numeric / (psut.n_tup_ins + psut.n_tup_upd + psut.n_tup_del)), 2)
        ELSE 999999
    END as read_to_write_ratio,
    CASE
        WHEN (COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0)) = 0 THEN 'READ_ONLY_PERFECT_FOR_CACHE'
        WHEN (COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0))::numeric / NULLIF((psut.n_tup_ins + psut.n_tup_upd + psut.n_tup_del), 0) > 100 THEN 'EXCELLENT_CACHE_CANDIDATE'
        WHEN (COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0))::numeric / NULLIF((psut.n_tup_ins + psut.n_tup_upd + psut.n_tup_del), 0) > 10 THEN 'GOOD_CACHE_CANDIDATE'
        ELSE 'POOR_CACHE_CANDIDATE'
    END as cache_recommendation,
    COALESCE(psut.n_live_tup, 0) as current_rows,
    pg_size_pretty(pg_total_relation_size(quote_ident(psut.schemaname)||'.'||quote_ident(psut.relname))) as total_size
FROM pg_stat_user_tables psut
WHERE psut.schemaname = 'public'
ORDER BY read_to_write_ratio DESC;

-- Este query identifica qué tablas benefician más de Redis caching:
-- - read_to_write_ratio alto = excelente candidato
-- - venues, events, fights deberían estar en top 3
-- - Útil para priorizar Phase 3 caching strategy

---

## Resumen de Cambios

### Scripts Sin Cambios (OK como están):
1. CURRENT_TABLES.json ✅
2. CURRENT_FOREIGN_KEYS.json ✅
3. CURRENT_ENUMS.json ✅
4. CURRENT_CONSTRAINTS.json ✅
5. COLUMN_STATISTICS.json ✅
10. FREQUENT_UPDATES.json ✅ (context-specific)

### Scripts Mejorados (más información útil):
3. CURRENT_INDEXES.json ⬆️ (agregado: size, usage stats, concurrency flag)
6. DATABASE_STATS.json ⬆️ (agregado: null_frac, avg_width, histogram)
8. REGISTROS_ESTIMADOS.json ⬆️ (agregado: dead_row_%, index_scan_%, ratios)
9. TABLE_SIZES.json ⬆️ (agregado: indexes_size, index_to_table_ratio)

### Scripts Nuevos (para Phase 2/3 analysis):
11. INDEX_USAGE_ANALYSIS.json 🆕 (analiza efectividad de los 7 nuevos indexes)
12. QUERY_PERFORMANCE_BASELINE.json 🆕 (baseline post-Phase 2)
13. CACHE_CANDIDATES.json 🆕 (identifica tablas para Redis Phase 3)

---

## Instrucciones de Uso

1. Copia cada SQL en Neon Tech console
2. Ejecuta y copia el resultado JSON
3. Guarda en el archivo correspondiente en `backend/database-analysis/`
4. Los 3 nuevos scripts (11-13) crean archivos nuevos

**Archivos a actualizar prioritariamente**:
- ✅ CURRENT_INDEXES.json (mejorado - verás los 7 nuevos indexes)
- ✅ REGISTROS_ESTIMADOS.json (mejorado - verás index usage stats)
- ✅ TABLE_SIZES.json (mejorado - verás crecimiento de indexes)
- 🆕 INDEX_USAGE_ANALYSIS.json (nuevo - crítico para validar Phase 2)
- 🆕 QUERY_PERFORMANCE_BASELINE.json (nuevo - baseline para Phase 3)
- 🆕 CACHE_CANDIDATES.json (nuevo - strategy para Redis)

**Opcional** (si tienes tiempo):
- DATABASE_STATS.json (mejorado)
- COLUMN_STATISTICS.json (sin cambios)
- FREQUENT_UPDATES.json (sin cambios)
