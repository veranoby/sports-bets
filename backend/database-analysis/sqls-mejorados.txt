# SQLs Mejorados para Database Analysis - Post Phase 2
# Fecha: 2025-10-12
# Cambios: Scripts mejorados para documentar los 7 nuevos performance indexes

## 1. CURRENT_TABLES.json (SIN CAMBIOS - OK)

SELECT
    t.table_name,
    c.column_name,
    c.data_type,
    c.character_maximum_length,
    c.is_nullable,
    c.column_default,
    c.ordinal_position
FROM information_schema.tables t
JOIN information_schema.columns c ON t.table_name = c.table_name
WHERE t.table_schema = 'public'
    AND t.table_type = 'BASE TABLE'
ORDER BY t.table_name, c.ordinal_position;

---

## 2. CURRENT_FOREIGN_KEYS.json (SIN CAMBIOS - OK)

SELECT
    tc.constraint_name,
    tc.table_name,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name,
    rc.update_rule,
    rc.delete_rule
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu
    ON ccu.constraint_name = tc.constraint_name
JOIN information_schema.referential_constraints rc
    ON tc.constraint_name = rc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
    AND tc.table_schema = 'public'
ORDER BY tc.table_name, tc.constraint_name;

---

## 3. CURRENT_INDEXES.json (MEJORADO - M√ÅS INFO)

-- Script mejorado para incluir m√°s informaci√≥n sobre indexes
SELECT
    pi.schemaname,
    pi.tablename,
    pi.indexname,
    pi.indexdef,
    CASE WHEN pi.indexdef LIKE '%UNIQUE%' THEN true ELSE false END as is_unique,
    CASE WHEN pi.indexdef LIKE '%CONCURRENTLY%' THEN true ELSE false END as created_concurrently,
    CASE WHEN pi.indexdef LIKE '%btree%' THEN 'btree'
         WHEN pi.indexdef LIKE '%hash%' THEN 'hash'
         WHEN pi.indexdef LIKE '%gin%' THEN 'gin'
         WHEN pi.indexdef LIKE '%gist%' THEN 'gist'
         ELSE 'other' END as index_type,
    pg_size_pretty(pg_relation_size(psi.indexrelid)) as index_size,
    COALESCE(psi.idx_scan, 0) as times_used,
    COALESCE(psi.idx_tup_read, 0) as tuples_read,
    COALESCE(psi.idx_tup_fetch, 0) as tuples_fetched
FROM pg_indexes pi
LEFT JOIN pg_stat_user_indexes psi ON pi.indexname = psi.indexrelname AND pi.schemaname = psi.schemaname
WHERE pi.schemaname = 'public'
ORDER BY pi.tablename, pi.indexname;

-- Nota: Este query mejorado muestra:
-- - Si el index fue creado CONCURRENTLY (como los 7 nuevos)
-- - Tama√±o del index en disco
-- - Estad√≠sticas de uso (times_used, tuples_read, tuples_fetched)
-- - √ötil para monitorear efectividad de los nuevos indexes

---

## 4. CURRENT_ENUMS.json (SIN CAMBIOS - OK)

SELECT
    t.typname as enum_name,
    array_agg(e.enumlabel ORDER BY e.enumsortorder) as enum_values
FROM pg_type t
JOIN pg_enum e ON t.oid = e.enumtypid
JOIN pg_namespace n ON n.oid = t.typnamespace
WHERE n.nspname = 'public'
GROUP BY t.typname
ORDER BY t.typname;

---

## 5. CURRENT_CONSTRAINTS.json (SIN CAMBIOS - OK)

SELECT
    tc.constraint_name,
    tc.table_name,
    tc.constraint_type,
    STRING_AGG(kcu.column_name, ', ' ORDER BY kcu.ordinal_position) as column_names,
    cc.check_clause
FROM information_schema.table_constraints tc
LEFT JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
LEFT JOIN information_schema.check_constraints cc
    ON tc.constraint_name = cc.constraint_name
WHERE tc.table_schema = 'public'
    AND tc.constraint_type IN ('PRIMARY KEY', 'UNIQUE', 'CHECK')
GROUP BY tc.constraint_name, tc.table_name, tc.constraint_type, cc.check_clause
ORDER BY tc.table_name, tc.constraint_type;

---

## 6. DATABASE_STATS.json (MEJORADO - M√ÅS CONTEXTO)

-- Script mejorado para incluir estad√≠sticas m√°s √∫tiles
SELECT
    ps.schemaname,
    ps.tablename,
    ps.attname as column_name,
    ps.n_distinct,
    ps.correlation,
    ps.null_frac,
    ps.avg_width,
    ps.most_common_vals::text as most_common_vals_sample,
    ps.histogram_bounds::text as histogram_sample
FROM pg_stats ps
WHERE ps.schemaname = 'public'
ORDER BY ps.tablename, ps.attname;

-- Agregado:
-- - null_frac: Porcentaje de valores NULL (importante para optimizaci√≥n)
-- - avg_width: Tama√±o promedio en bytes (√∫til para calcular memoria)
-- - histogram_bounds: Sample de distribuci√≥n de datos

---

## 7. COLUMN_STATISTICS.json (SIN CAMBIOS - OK)

SELECT
    table_schema,
    table_name,
    column_name,
    data_type,
    is_nullable,
    column_default
FROM information_schema.columns
WHERE table_schema = 'public'
ORDER BY table_name, ordinal_position;

---

## 8. REGISTROS_ESTIMADOS.json (MEJORADO - M√ÅS √öTIL)

-- Script mejorado con m√°s estad√≠sticas de actividad
SELECT
    psut.schemaname,
    psut.relname as tablename,
    COALESCE(psut.n_tup_ins, 0) as total_inserts,
    COALESCE(psut.n_tup_upd, 0) as total_updates,
    COALESCE(psut.n_tup_del, 0) as total_deletes,
    COALESCE(psut.n_live_tup, 0) as current_rows,
    COALESCE(psut.n_dead_tup, 0) as dead_rows,
    ROUND((psut.n_dead_tup::numeric / NULLIF(psut.n_live_tup, 0)) * 100, 2) as dead_row_percentage,
    COALESCE(psut.seq_scan, 0) as sequential_scans,
    COALESCE(psut.seq_tup_read, 0) as sequential_tuples_read,
    COALESCE(psut.idx_scan, 0) as index_scans,
    COALESCE(psut.idx_tup_fetch, 0) as index_tuples_fetched,
    CASE
        WHEN COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0) > 0
        THEN ROUND((psut.idx_scan::numeric / (psut.seq_scan + psut.idx_scan)) * 100, 2)
        ELSE 0
    END as index_scan_percentage,
    psut.last_vacuum,
    psut.last_autovacuum,
    psut.last_analyze,
    psut.last_autoanalyze
FROM pg_stat_user_tables psut
WHERE psut.schemaname = 'public'
ORDER BY psut.relname;

-- Agregado:
-- - dead_row_percentage: % de filas muertas (indica necesidad de VACUUM)
-- - sequential_scans vs index_scans: Ratio de uso de indexes
-- - index_scan_percentage: % de queries que usan indexes (meta: >90%)

---

## 9. TABLE_SIZES.json (MEJORADO - M√ÅS DETALLE)

-- Script mejorado con m√°s informaci√≥n de tama√±o
SELECT
    pt.schemaname,
    pt.tablename,
    pg_size_pretty(pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename))) as total_size,
    pg_size_pretty(pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename))) as table_size,
    pg_size_pretty(pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) - pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename))) as indexes_size,
    ROUND(
        (pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) - pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)))::numeric /
        NULLIF(pg_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)), 0) * 100,
        2
    ) as index_to_table_ratio_percentage,
    pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) as total_bytes
FROM pg_tables pt
WHERE pt.schemaname = 'public'
ORDER BY pg_total_relation_size(quote_ident(pt.schemaname)||'.'||quote_ident(pt.tablename)) DESC;

-- Agregado:
-- - indexes_size: Tama√±o total de todos los indexes de la tabla
-- - index_to_table_ratio: Ratio de tama√±o indexes vs table (√∫til para optimizaci√≥n)
-- - total_bytes: Tama√±o en bytes para c√°lculos program√°ticos

---

## 10. FREQUENT_UPDATES.json (SIN CAMBIOS - OK, pero context-specific)

SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    most_common_vals
FROM pg_stats
WHERE tablename = 'users'
ORDER BY attname;

-- Nota: Este query es espec√≠fico para 'users' table
-- Si quieres generalizarlo para todas las tablas:

-- ALTERNATIVE: FREQUENT_UPDATES_ALL_TABLES.json
SELECT
    ps.schemaname,
    ps.tablename,
    ps.attname,
    ps.n_distinct,
    ps.most_common_vals::text as common_values_sample,
    ps.correlation
FROM pg_stats ps
WHERE ps.schemaname = 'public'
ORDER BY ps.tablename, ps.attname;

---

## NUEVO: 11. INDEX_USAGE_ANALYSIS.json (AGREGADO)

-- Nuevo script para analizar efectividad de los 7 nuevos indexes
SELECT
    psi.schemaname,
    psi.relname as tablename,
    psi.indexrelname as indexname,
    COALESCE(psi.idx_scan, 0) as times_used,
    COALESCE(psi.idx_tup_read, 0) as tuples_read,
    COALESCE(psi.idx_tup_fetch, 0) as tuples_fetched,
    pg_size_pretty(pg_relation_size(psi.indexrelid)) as index_size,
    CASE
        WHEN COALESCE(psi.idx_scan, 0) = 0 THEN 'UNUSED'
        WHEN psi.idx_scan < 100 THEN 'LOW_USAGE'
        WHEN psi.idx_scan < 1000 THEN 'MEDIUM_USAGE'
        ELSE 'HIGH_USAGE'
    END as usage_category,
    ROUND(
        CASE
            WHEN COALESCE(psi.idx_tup_read, 0) > 0
            THEN (psi.idx_tup_fetch::numeric / psi.idx_tup_read) * 100
            ELSE 0
        END,
        2
    ) as fetch_efficiency_percentage
FROM pg_stat_user_indexes psi
WHERE psi.schemaname = 'public'
ORDER BY psi.idx_scan DESC NULLS LAST;

-- Este query es CR√çTICO para Phase 3:
-- - Muestra cu√°ntas veces se us√≥ cada index
-- - Identifica indexes no usados (candidatos para eliminar)
-- - Calcula eficiencia de fetch (meta: >80%)
-- - Los 7 nuevos indexes deber√≠an aparecer aqu√≠

---

## NUEVO: 12. QUERY_PERFORMANCE_BASELINE.json (AGREGADO)

-- Nuevo script para establecer baseline de performance post-Phase 2
SELECT
    psut.schemaname,
    psut.relname as tablename,
    COALESCE(psut.seq_scan, 0) as sequential_scans,
    COALESCE(psut.seq_tup_read, 0) as seq_tuples_read,
    COALESCE(psut.idx_scan, 0) as index_scans,
    COALESCE(psut.idx_tup_fetch, 0) as idx_tuples_fetched,
    COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0) as total_modifications,
    COALESCE(psut.n_live_tup, 0) as current_rows,
    CASE
        WHEN COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0) > 0
        THEN ROUND((psut.idx_scan::numeric / (psut.seq_scan + psut.idx_scan)) * 100, 2)
        ELSE 0
    END as index_usage_percentage,
    CASE
        WHEN COALESCE(psut.seq_scan, 0) > COALESCE(psut.idx_scan, 0) THEN 'ADD_MORE_INDEXES'
        WHEN COALESCE(psut.idx_scan, 0) > COALESCE(psut.seq_scan, 0) * 10 THEN 'WELL_INDEXED'
        ELSE 'MODERATE_INDEXING'
    END as indexing_health
FROM pg_stat_user_tables psut
WHERE psut.schemaname = 'public'
ORDER BY psut.relname;

-- Este query establece un baseline de performance:
-- - Compara sequential scans vs index scans
-- - Meta: index_usage_percentage > 90%
-- - √ötil para comparar antes/despu√©s de Redis (Phase 3)

---

## NUEVO: 13. CACHE_CANDIDATES.json (AGREGADO)

-- Nuevo script para identificar tablas candidatas para caching
SELECT
    psut.schemaname,
    psut.relname as tablename,
    COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0) as total_reads,
    COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0) as total_writes,
    CASE
        WHEN (COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0)) > 0
        THEN ROUND(((COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0))::numeric / (psut.n_tup_ins + psut.n_tup_upd + psut.n_tup_del)), 2)
        ELSE 999999
    END as read_to_write_ratio,
    CASE
        WHEN (COALESCE(psut.n_tup_ins, 0) + COALESCE(psut.n_tup_upd, 0) + COALESCE(psut.n_tup_del, 0)) = 0 THEN 'READ_ONLY_PERFECT_FOR_CACHE'
        WHEN (COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0))::numeric / NULLIF((psut.n_tup_ins + psut.n_tup_upd + psut.n_tup_del), 0) > 100 THEN 'EXCELLENT_CACHE_CANDIDATE'
        WHEN (COALESCE(psut.seq_scan, 0) + COALESCE(psut.idx_scan, 0))::numeric / NULLIF((psut.n_tup_ins + psut.n_tup_upd + psut.n_tup_del), 0) > 10 THEN 'GOOD_CACHE_CANDIDATE'
        ELSE 'POOR_CACHE_CANDIDATE'
    END as cache_recommendation,
    COALESCE(psut.n_live_tup, 0) as current_rows,
    pg_size_pretty(pg_total_relation_size(quote_ident(psut.schemaname)||'.'||quote_ident(psut.relname))) as total_size
FROM pg_stat_user_tables psut
WHERE psut.schemaname = 'public'
ORDER BY read_to_write_ratio DESC;

-- Este query identifica qu√© tablas benefician m√°s de Redis caching:
-- - read_to_write_ratio alto = excelente candidato
-- - venues, events, fights deber√≠an estar en top 3
-- - √ötil para priorizar Phase 3 caching strategy

---

## Resumen de Cambios

### Scripts Sin Cambios (OK como est√°n):
1. CURRENT_TABLES.json ‚úÖ
2. CURRENT_FOREIGN_KEYS.json ‚úÖ
3. CURRENT_ENUMS.json ‚úÖ
4. CURRENT_CONSTRAINTS.json ‚úÖ
5. COLUMN_STATISTICS.json ‚úÖ
10. FREQUENT_UPDATES.json ‚úÖ (context-specific)

### Scripts Mejorados (m√°s informaci√≥n √∫til):
3. CURRENT_INDEXES.json ‚¨ÜÔ∏è (agregado: size, usage stats, concurrency flag)
6. DATABASE_STATS.json ‚¨ÜÔ∏è (agregado: null_frac, avg_width, histogram)
8. REGISTROS_ESTIMADOS.json ‚¨ÜÔ∏è (agregado: dead_row_%, index_scan_%, ratios)
9. TABLE_SIZES.json ‚¨ÜÔ∏è (agregado: indexes_size, index_to_table_ratio)

### Scripts Nuevos (para Phase 2/3 analysis):
11. INDEX_USAGE_ANALYSIS.json üÜï (analiza efectividad de los 7 nuevos indexes)
12. QUERY_PERFORMANCE_BASELINE.json üÜï (baseline post-Phase 2)
13. CACHE_CANDIDATES.json üÜï (identifica tablas para Redis Phase 3)

---

## Instrucciones de Uso

1. Copia cada SQL en Neon Tech console
2. Ejecuta y copia el resultado JSON
3. Guarda en el archivo correspondiente en `backend/database-analysis/`
4. Los 3 nuevos scripts (11-13) crean archivos nuevos

**Archivos a actualizar prioritariamente**:
- ‚úÖ CURRENT_INDEXES.json (mejorado - ver√°s los 7 nuevos indexes)
- ‚úÖ REGISTROS_ESTIMADOS.json (mejorado - ver√°s index usage stats)
- ‚úÖ TABLE_SIZES.json (mejorado - ver√°s crecimiento de indexes)
- üÜï INDEX_USAGE_ANALYSIS.json (nuevo - cr√≠tico para validar Phase 2)
- üÜï QUERY_PERFORMANCE_BASELINE.json (nuevo - baseline para Phase 3)
- üÜï CACHE_CANDIDATES.json (nuevo - strategy para Redis)

**Opcional** (si tienes tiempo):
- DATABASE_STATS.json (mejorado)
- COLUMN_STATISTICS.json (sin cambios)
- FREQUENT_UPDATES.json (sin cambios)
