{
  "metadata": {
    "purpose": "Documented lessons learned and prevention strategies for future development",
    "updated": "2025-09-13",
    "version": "1.1",
    "cross_references": ["backlog.json", "sdd_system.json"]
  },
  "critical_lessons": {
    "freemium_manual_membership_implementation": {
      "date": "2025-09-13",
      "error_description": "Initial feature implementation was blocked by a massively failing frontend build, with hundreds of pre-existing TypeScript errors across the entire codebase.",
      "correct_approach": "1. Isolate and verify backend changes independently. 2. For frontend, use `write_file` instead of `replace` for complex changes to avoid file corruption. 3. Systematically debug build errors starting with the most direct ones (e.g., `import type`) before assuming project-wide corruption.",
      "root_cause_analysis": [
        "The frontend project was in a non-compilable state prior to the start of the task.",
        "The `replace` tool proved unreliable for `.tsx` files, causing file corruption that masked underlying issues.",
        "The project's strict TypeScript configuration (`verbatimModuleSyntax`) was not initially accounted for, causing `import type` syntax errors.",
        "The work plan (`claude-prompt.json`) contained multiple inaccuracies regarding file paths and data types which required manual discovery and correction."
      ],
      "prevention_strategy": {
        "before_any_work": [
          "CRITICAL: Run a full build of both frontend (`cd frontend && npm run build`) and backend (`cd backend && npx tsc`) to establish a baseline. Do not start work if the build is failing."
        ],
        "tooling_guidelines": [
          "WARNING: Avoid using the `replace` tool for complex JSX/TSX files. Prefer reading the file, modifying the content in memory, and overwriting with `write_file` to prevent corruption."
        ],
        "project_compliance": [
          "SUGGESTION: Always use `import type { ... } from '...'` for type/interface imports in the frontend to comply with `verbatimModuleSyntax`.",
          "NOTE: Do not blindly trust the work plan. Always verify file paths (using `list_directory`) and data types (reading `frontend/src/types/index.ts`) against the actual project structure."
        ]
      },
      "implementation_summary": {
        "backend_status": "✅ COMPLETED AND VERIFIED",
        "backend_details": "Backend 100% implemented per claude-prompt.json: Subscription model extended, 3 API endpoints created, multer upload configured. TypeScript compilation successful.",
        "frontend_status": "✅ COMPLETED AND VERIFIED", 
        "frontend_details": "All components implemented and verified: UserMembershipPanel (admin), PaymentProofUpload (user), useMembershipCheck hook, Profile.tsx + VideoPlayer.tsx integrations, API services updated.",
        "verification_completed_by": "Claude Code on 2025-09-13",
        "implementation_quality": "EXCELLENT - 100% adherence to specifications, proper TypeScript types, error handling, localStorage caching, UX considerations",
        "uncompleted_work": "NONE - Full implementation verification completed successfully"
      }
    },
    "gemini_dependency_management_failure": {
      "date": "2025-09-13",
      "error_description": "Gemini implemented payment proof upload functionality but failed to install required dependencies (multer) and properly structure TypeScript imports, causing npm run dev failures",
      "correct_approach": "1. ALWAYS specify dependency installation as explicit tasks. 2. Provide complete file structure including imports. 3. Specify TypeScript source files as targets, not compiled JS. 4. Include verification steps for dev server startup.",
      "root_cause_analysis": [
        "claude-prompt.json specified code implementation but omitted dependency management as explicit task",
        "Gemini added code to compiled .js files instead of source .ts files", 
        "Missing multer dependency installation caused runtime ReferenceError",
        "No verification step specified for 'npm run dev' functionality",
        "Import statements were not explicitly specified in the work plan"
      ],
      "prevention_strategy": {
        "dependency_management": [
          "CRITICAL: Add explicit 'task_0_install_dependencies' with exact npm install commands",
          "List ALL new dependencies including @types packages for TypeScript",
          "Specify package.json verification step post-installation"
        ],
        "file_targeting": [
          "ALWAYS specify .ts source files as targets, NEVER .js compiled files",
          "Include explicit import statements in code specifications",
          "Provide complete file header with all required imports"
        ],
        "verification_requirements": [
          "Add explicit verification task: 'npm run dev must start without errors'",
          "Include TypeScript compilation verification: 'npx tsc must pass'",
          "Specify server startup confirmation as success criteria"
        ],
        "work_plan_completeness": [
          "Dependencies → Source Code → Compilation → Verification - complete pipeline",
          "Never assume dependencies are installed - always specify explicitly",
          "Include rollback instructions if implementation fails verification"
        ]
      },
      "enhanced_claude_prompt_template": {
        "task_0_dependencies": {
          "execution": "MANDATORY_FIRST_STEP",
          "description": "Install all required dependencies before code implementation",
          "commands": ["npm install multer @types/multer", "npm list multer @types/multer"],
          "verification": "Dependencies appear in package.json and node_modules"
        },
        "task_N_implementation": {
          "target_file_type": "SOURCE_FILE.ts (NEVER compiled .js)",
          "required_imports": ["import multer from 'multer';", "import path from 'path';"],
          "code_placement": "Add after existing imports, before router export"
        },
        "task_final_verification": {
          "commands": ["npx tsc", "npm run dev"],
          "success_criteria": ["No TypeScript errors", "Server starts on port 3001", "All routes load successfully"],
          "failure_protocol": "Report specific error and request debugging assistance"
        }
      }
    },
    "operator_environment_architecture": {
      "date": "2025-09-09",
      "error_description": "Created standalone operator components (/pages/operator/) instead of using admin environment with role hierarchy",
      "correct_approach": "Operators use admin interface with role-based filtering in AdminSidebar.tsx",
      "root_cause_analysis": [
        "Misinterpreted requirement - assumed 'operator environment' meant separate UI",
        "Did not analyze existing AdminSidebar hierarchy system before implementation",
        "Reacted to missing import errors without understanding architectural context"
      ],
      "prevention_strategy": {
        "before_component_creation": [
          "Check existing AdminSidebar.tsx for role hierarchy patterns",
          "Verify App.tsx routing architecture for role-based access",
          "Understand 'environment' vs 'separate interface' distinction",
          "Read brain files (sdd_system.json) for architectural decisions"
        ],
        "analysis_first_approach": [
          "When encountering missing component errors, analyze WHY they're missing",
          "Question if separate components are needed vs extending existing ones",
          "Consult with user about architecture before creating new patterns"
        ]
      },
      "correct_implementation": {
        "AdminSidebar_pattern": "Declarative role permissions: { path, icon, label, roles: ['admin', 'operator'] }",
        "routing_pattern": "Single admin routes with allowedRoles: ['admin', 'operator']",
        "visual_indicators": "Role-based styling (admin=red, operator=blue badges)",
        "access_control": "Filter navigation items based on user.role inclusion in roles array"
      }
    }
  },
  "development_principles": {
    "dependency_first_principle": {
      "rule": "ALWAYS specify dependency management as Task 0 before any code implementation",
      "rationale": "Missing dependencies cause runtime failures that are harder to debug than missing code",
      "implementation": [
        "Start every claude-prompt.json with explicit npm install commands",
        "Verify dependencies are installed before proceeding to code tasks",
        "Include both runtime and @types packages for TypeScript projects"
      ]
    },
    "source_file_targeting": {
      "rule": "ALWAYS target .ts source files, NEVER compiled .js files",
      "rationale": "Compiled files get overwritten on build, changes must be in source",
      "implementation": [
        "Specify 'file_to_modify: backend/src/routes/users.ts'",  
        "Include complete import statements in specifications",
        "Verify TypeScript compilation after changes"
      ]
    },
    "verification_completeness": {
      "rule": "ALWAYS include end-to-end verification as final task",
      "rationale": "Implementation without verification leads to broken development environment",
      "implementation": [
        "Add 'npm run dev' startup verification",
        "Include specific success criteria (port, no errors, routes loaded)",
        "Specify failure protocol and debugging steps"
      ]
    },
    "architecture_first": {
      "rule": "Always analyze existing architecture before creating new components",
      "tools": [
        "Read AdminSidebar.tsx for role patterns",
        "Check App.tsx for routing architecture", 
        "Review brain/*.json files for documented decisions",
        "Understand user role hierarchy from existing code"
      ]
    },
    "shared_vs_separate": {
      "rule": "Default to extending existing interfaces with restrictions vs creating separate ones",
      "benefits": [
        "Consistent user experience across roles",
        "Reduced code duplication",
        "Easier maintenance and updates",
        "Single source of truth for UI patterns"
      ]
    },
    "error_investigation": {
      "rule": "Investigate WHY components are missing before creating them",
      "process": [
        "Analyze the error context and architectural fit",
        "Check if existing components can be extended",
        "Verify if separate components align with system design",
        "Consult documentation and user requirements"
      ]
    }
  },
  "implementation_patterns": {
    "role_based_ui_filtering": {
      "pattern_name": "Declarative Role Permissions",
      "implementation": "Array-based role checking: item.roles.includes(user.role)",
      "example": "{ path: '/admin/articles', roles: ['admin', 'operator'] }",
      "benefits": ["Easy to maintain", "Self-documenting", "Scalable for new roles"]
    },
    "unified_admin_environment": {
      "pattern_name": "Single Interface with Role Restrictions",
      "approach": "Same components, different permissions based on user.role",
      "visual_differentiation": "Role badges, conditional styling, restricted sections",
      "navigation_control": "Filtered sidebar items, conditional route access"
    }
  },
  "quality_gates": {
    "before_new_components": [
      "✅ Analyze existing similar components",
      "✅ Check brain files for architectural guidance",
      "✅ Verify role hierarchy requirements", 
      "✅ Consider extension vs creation trade-offs"
    ],
    "role_based_features": [
      "✅ Use declarative role arrays for permissions",
      "✅ Implement visual role differentiation",
      "✅ Test with different user roles",
      "✅ Document role restrictions clearly"
    ],
    "gemini_claude_prompt_creation": [
      "✅ Start with Task 0: Install dependencies (npm install commands)",
      "✅ Target .ts source files explicitly, never compiled .js",
      "✅ Include complete import statements in specifications",
      "✅ Add verification task: 'npm run dev must start successfully'",
      "✅ Specify TypeScript compilation verification: 'npx tsc'",
      "✅ Include rollback protocol if implementation fails",
      "✅ Verify all @types packages are included for TypeScript"
    ],
    "implementation_verification": [
      "✅ Dependencies installed before code changes", 
      "✅ Source files modified, not compiled files",
      "✅ TypeScript compilation passes without errors",
      "✅ Development server starts successfully",
      "✅ All routes load without runtime errors",
      "✅ No missing import statements or undefined references"
    ]
  },
  "improved_claude_prompt_template": {
    "metadata": {
      "purpose": "Template for creating robust claude-prompt.json files that prevent implementation failures",
      "created_from_lesson": "gemini_dependency_management_failure", 
      "usage": "Copy this structure when creating new claude-prompt.json files for Gemini"
    },
    "required_structure": {
      "task_0_prerequisites": {
        "execution": "MANDATORY_FIRST_STEP",
        "description": "Install all required dependencies and verify environment",
        "commands": [
          "npm install [specific-package] @types/[specific-package]",
          "npm list [specific-package] @types/[specific-package]"
        ],
        "verification": "Dependencies visible in package.json and node_modules",
        "estimated_time": "10min"
      },
      "task_N_source_file_modification": {
        "file_to_modify": "[ABSOLUTE_PATH_TO_SOURCE_FILE.ts]",
        "description": "Add [specific functionality] to existing [component/service]",
        "required_imports": [
          "import [package] from '[package-name]';",
          "import { [specific-exports] } from '[package-name]';"
        ],
        "exact_modifications": {
          "add_after_existing_imports": "[complete import block]",
          "add_before_export_default": "[complete implementation code]"
        },
        "estimated_time": "[realistic estimate]"
      },
      "task_final_verification": {
        "execution": "MANDATORY_FINAL_STEP",
        "description": "Verify complete implementation works in development environment",
        "verification_commands": [
          "npx tsc",
          "npm run dev"
        ],
        "success_criteria": [
          "TypeScript compilation passes with zero errors",
          "Development server starts on expected port",
          "All routes load without runtime errors",
          "New functionality accessible via API/UI"
        ],
        "failure_protocol": "If any verification fails, report specific error and request immediate debugging assistance",
        "estimated_time": "15min"
      }
    },
    "critical_specifications": {
      "file_targeting": "ALWAYS specify .ts source files, NEVER .js compiled files",
      "dependency_management": "ALWAYS include npm install as Task 0",
      "import_completeness": "ALWAYS specify exact import statements required",
      "verification_requirement": "ALWAYS include working development server as success criteria"
    },
    "example_usage": {
      "good_example": "file_to_modify: 'backend/src/routes/users.ts'",
      "bad_example": "file_to_modify: 'backend/src/routes/users.js'",
      "good_dependencies": "npm install multer @types/multer",
      "bad_dependencies": "[assumed multer is already installed]"
    }
  }
}