{
  "metadata": {
    "purpose": "Optimized TypeScript interface reference for Galleros.Net platform",
    "version": "3.7",
    "last_updated": "2025-12-05",
    "changelog": "v3.7 (2025-12-05): Added comprehensive Wallet model interface documentation with PostgreSQL DECIMAL string serialization pattern (parseFloat(String()) usage). Documents critical frozenAmount logic and admin debit validation. v3.6 (2025-12-05): CRITICAL FIX - Wallet.create() now called automatically when admin creates users (backend/src/routes/users.ts:680-684). Fixes \"User wallet not found\" errors on balance adjustments. Added response.success check to handleAdjustBalance (frontend/src/components/admin/UserModal.tsx:117) to prevent modal closing on API errors. v3.5: Added admin_credit/admin_debit to Transaction type enum + PostgreSQL migration. Implemented admin balance adjustment feature in UserModal with ConfirmDialog integration.",
    "streaming_infrastructure": "Nginx RTMP (self-managed) + PostgreSQL local (OPTION B.1)",
    "required_environment_variables": {
      "VITE_STREAM_BASE_URL": "HLS stream base URL (Phase 1: Nginx, Phase 2: CDN)",
      "VITE_API_URL": "API base URL",
      "VITE_WS_URL": "WebSocket base URL"
    },
    "phase_2_bunny_cdn_readiness": "HLSPlayer component uses VITE_STREAM_BASE_URL environment variable (zero code changes needed for CDN switch)",
    "note": "Verified against backend database models and production deployment",
    "optimization_date": "2025-12-05 - Restructured for improved readability and maintainability while preserving all original information"
  },

  "quick_reference": {
    "core_interfaces": [
      "AlertItem", "LiveStats", "Fight", "Bet", "SSEEventType", "User", "UserSubscription", "UserSubscriptionWithExpiry"
    ],
    "admin_interfaces": [
      "MembershipChangeRequest", "EventConnection", "EventData", "Venue", "Article", "Gallera", "UserProfileWithSubscription"
    ],
    "wallet_interfaces": [
      "Wallet", "WalletOperation", "Transaction", "SystemSetting", "Bet_PAGO_DOY_Enhanced"
    ],
    "frontend_components": [
      "ImageGalleryUpload", "UnifiedEntityForm", "OptimizedStreamingMonitor"
    ],
    "hooks": [
      "useSSEConnection", "useUserForm", "useUserSubscription"
    ],
    "feature_flags": [
      "FeatureFlags"
    ]
  },

  "core_data_models": {
    "User": {
      "file": "/frontend/src/types/index.ts",
      "required_properties": ["id", "username", "email", "role", "isActive", "approved", "createdAt", "updatedAt"],
      "optional_properties": ["profileInfo", "lastLogin", "subscription", "wallet", "events"],
      "role_enum": ["admin", "operator", "venue", "user", "gallera"],
      "approval_system": {
        "approved_field": "boolean - NEW FIELD 2025-10-29",
        "default_value": "false for public registrations, true for admin-created users",
        "approval_logic": "Users with role='venue'|'gallera' and approved=false are blocked by middleware until admin approves",
        "middleware_check": "authenticate middleware checks approved status before allowing requests"
      },
      "profileInfo_structure": {
        "basic_fields": ["fullName", "phoneNumber", "address", "identificationNumber", "verificationLevel"],
        "image_fields": ["images?: string[] - ADDED 2025-10-31 - Max 2 for venues, max 3 for galleras"],
        "venue_fields": ["businessName", "venueName", "venueLocation", "venueDescription", "venueEmail", "venueWebsite"],
        "gallera_fields": ["galleraName", "galleraLocation", "galleraDescription", "galleraEmail", "galleraWebsite", "galleraSpecialties", "galleraActiveRoosters"],
        "extended_fields": ["location", "description", "establishedDate", "certified", "rating", "premiumLevel", "specialties", "imageUrl"]
      },
      "backend_sync": {
        "critical_note_2025_10_30": "CONSOLIDATED ARCHITECTURE - NO SYNC NEEDED",
        "architecture_note": "venues and galleras tables ELIMINATED. All data stored ONLY in User.profileInfo JSONB field. NO sync to dedicated tables (tables eliminated 2025-11-04)",
        "profile_data_location": "User.profileInfo (single source of truth)",
        "endpoint": "/users/profile (PUT) - updates User.profileInfo directly, no sync to other tables needed"
      }
    },
    "UserSubscription": {
      "file": "/frontend/src/types/index.ts",
      "required_properties": ["id", "plan", "status", "features"],
      "optional_properties": ["expiresAt", "manual_expires_at"],
      "status_enum": ["active", "cancelled", "expired", "pending"],
      "plan_types": ["free", "24-hour", "monthly"],
      "pricing": {
        "free": "$0 (default on expiration/cancellation)",
        "24-hour": "$5 (1 day access)",
        "monthly": "$10 (30 days access)"
      },
      "expiration_behavior": {
        "automatic_downgrade": "When expiresAt < current_timestamp, subscription automatically changes to 'free' type",
        "frontend_access_control": "Frontend components automatically restrict access to premium content when subscription expires",
        "middleware_validation": "authenticate middleware checks expiresAt on each request and enforces access restrictions",
        "immediate_effect": "Access restrictions take effect immediately when subscription expires without need for user logout/login"
      },
      "common_errors": [
        "Using 'type' instead of 'plan' property",
        "Missing 'id' property in form data",
        "Forgetting index signature for form compatibility"
      ]
    },
    "UserSubscriptionWithExpiry": {
      "file": "/frontend/src/types/index.ts",
      "extends": "UserSubscription",
      "additional_properties_for_frontend": ["expiresAt", "manual_expires_at", "current_status"],
      "computed_property": {
        "current_status": "Calculated property that combines status and expiresAt to determine if user has active access",
        "calculation": "status === 'active' && (expiresAt ? new Date(expiresAt) > new Date() : true) ? 'active_access' : 'limited_access'"
      },
      "frontend_usage": {
        "component": "/frontend/src/components/user/SubscriptionGuard.tsx",
        "purpose": "Component that hides/shows content based on subscription status",
        "access_control": "Blocks access to premium content when subscription is expired/inactive"
      }
    },
    "AlertItem": {
      "file": "/frontend/src/pages/admin/Monitoring.tsx",
      "purpose": "Type definition for system alert items displayed in monitoring UI",
      "required_properties": ["id", "level", "service", "message", "timestamp", "resolved"],
      "interface": {
        "id": "string - unique alert identifier (format: alert_${timestamp}_${service})",
        "level": "'critical' | 'warning' | 'info' - severity level",
        "service": "string - alert source (Database, Memory, Intervals, System)",
        "message": "string - human-readable alert description",
        "timestamp": "string - ISO date when alert was created",
        "resolved": "boolean - alert acknowledgment status"
      },
      "ui_color_mapping": {
        "critical": "text-red-500 bg-red-50 border-red-200 - XCircle icon",
        "warning": "text-yellow-500 bg-yellow-50 border-yellow-200 - AlertTriangle icon",
        "info": "text-blue-500 bg-blue-50 border-blue-200 - CheckCircle icon"
      },
      "alert_sources": {
        "Database Connections": "Triggered when pool.using > 8/10",
        "Database Queue": "Triggered when pool.queue > 0",
        "Database Status": "Triggered when pool.status !== 'active'",
        "Memory Critical": "Triggered when memory > 380MB (95% of 400MB)",
        "Memory High": "Triggered when memory > 300MB (75% of 400MB)",
        "Intervals": "Triggered when activeCount > 50 (potential memory leak)",
        "System": "Info alert when no other alerts exist"
      },
      "backend_source": "backend/src/routes/monitoring.ts:252-345",
      "api_endpoint": "GET /api/monitoring/alerts",
      "frontend_usage": [
        "Monitoring.tsx:334 - alerts.filter((alert) => !alert.resolved).length",
        "Monitoring.tsx:352-395 - Render alert list with color coding"
      ],
      "implementation_date": "2025-11-19 (fixed alerts.filter is not a function error)"
    },
    "LiveStats": {
      "file": "/frontend/src/pages/admin/Monitoring.tsx",
      "purpose": "Type definition for live system statistics displayed in monitoring dashboard",
      "required_properties": ["activeUsers", "liveEvents", "activeBets", "connectionCount", "requestsPerMinute", "errorRate"],
      "interface": {
        "activeUsers": "number - Currently implemented with EventConnection.count() for active connections",
        "liveEvents": "number - Currently implemented with Events.count() for active events with status='live'",
        "activeBets": "number - Currently implemented with Bets.count() for active bets with status='active'",
        "connectionCount": "number - Current database pool active connections (real)",
        "requestsPerMinute": "number - Currently implemented with performance tracking middleware",
        "errorRate": "number - Currently implemented with error tracking from monitoring services"
      },
      "future_integration": {
        "activeUsers": "TODO: Integrate EventConnection.count({ disconnected_at: null })",
        "liveEvents": "TODO: Integrate Event.count({ status: 'live' })",
        "activeBets": "TODO: Integrate Bet.count({ status: 'active' })",
        "requestsPerMinute": "TODO: Add tracking in performance middleware",
        "errorRate": "TODO: Add tracking in error middleware"
      },
      "backend_source": "backend/src/routes/monitoring.ts:351-386",
      "api_endpoint": "GET /api/monitoring/stats",
      "display_format": {
        "activeUsers": "Large metric card with Users icon (blue)",
        "liveEvents": "Large metric card with Zap icon (red)",
        "activeBets": "Large metric card with Activity icon (green) - admin only",
        "connectionCount": "Large metric card with Wifi icon (purple) - admin only",
        "requestsPerMinute": "Large metric card with Clock icon (yellow) - admin only",
        "errorRate": "Percentage display with AlertTriangle icon (red) - admin only"
      },
      "admin_visibility": {
        "all_users": ["activeUsers", "liveEvents"],
        "admin_only": ["activeBets", "connectionCount", "requestsPerMinute", "errorRate"]
      },
      "frontend_usage": [
        "Monitoring.tsx:209-299 - 6 stat cards with conditional rendering based on role",
        "Monitoring.tsx:216-217 - activeUsers display",
        "Monitoring.tsx:230-231 - liveEvents display",
        "Monitoring.tsx:246-247 - activeBets display (admin only)"
      ],
      "implementation_date": "2025-11-19 (fixed monitoring page broken state)"
    },
    "Fight": {
      "file": "/frontend/src/types/index.ts",
      "required_properties": ["id", "eventId", "number", "redCorner", "blueCorner", "weight", "status"],
      "optional_properties": ["description", "notes", "initialOdds", "bettingStartTime", "bettingEndTime", "result", "startTime", "endTime"],
      "status_enum": ["upcoming", "betting", "live", "completed", "cancelled"],
      "database_mapping": {
        "redCorner": "red_corner (database)",
        "blueCorner": "blue_corner (database)",
        "bettingStartTime": "betting_start_time (database)"
      },
      "critical_note": "VERIFIED against backend/src/models/Fight.ts - properties match database schema"
    },
    "Bet": {
      "file": "/backend/src/models/Bet.ts",
      "purpose": "Betting system with support for standard bets and PAGO/DOY matched proposals",
      "required_properties": ["id", "fightId", "userId", "side", "amount", "potentialWin", "status", "betType"],
      "optional_properties": ["matchedWith", "proposalStatus", "terms", "createdAt", "updatedAt"],
      "side_enum": ["red", "blue"],
      "status_enum": ["pending", "active", "won", "lost", "cancelled", "refunded"],
      "betType_enum": ["flat", "doy"],
      "proposalStatus_enum": ["pending", "accepted", "rejected", "expired"],
      "pago_doy_specific_fields": {
        "critical_fix_2025_11_04": "PAGO/DOY matched bets now persist to database with transaction safety",
        "matchedWith": {
          "type": "string | null",
          "description": "ID of matched bet (bidirectional link between PAGO and DOY bets)",
          "usage": "PAGO bet.matchedWith = DOY bet.id, DOY bet.matchedWith = PAGO bet.id"
        },
        "proposalStatus": {
          "type": "'pending' | 'accepted' | 'rejected' | 'expired' | null",
          "description": "Status of PAGO/DOY proposal lifecycle",
          "workflow": "pending (created) â†’ accepted (matched) OR expired (timeout) OR rejected (declined)"
        },
        "terms": {
          "type": "object | null",
          "description": "PAGO/DOY proposal terms and metadata",
          "structure": {
            "ratio": "number (betting odds ratio)",
            "isOffer": "boolean (true for PAGO, false for DOY)",
            "pagoAmount": "number (PAGO bet amount)",
            "doyAmount": "number (DOY bet amount)",
            "proposedBy": "string (userId who created PAGO proposal)"
          }
        }
      },
      "database_persistence": {
        "transaction_pattern": "Matched bets created atomically with Sequelize transaction",
        "implementation": "backend/src/sockets/bettingSocket.ts:215-271",
        "pago_bet": {
          "betType": "'doy'",
          "proposalStatus": "'accepted'",
          "terms.isOffer": true,
          "matchedWith": "DOY bet ID (linked after DOY creation)"
        },
        "doy_bet": {
          "betType": "'doy'",
          "proposalStatus": "'accepted'",
          "terms.isOffer": false,
          "matchedWith": "PAGO bet ID (linked during creation)"
        },
        "rollback_behavior": "Transaction rollback on any error, both bets or none"
      },
      "common_errors": [
        "Missing matchedWith link in one direction",
        "Inconsistent proposalStatus between matched bets",
        "Transaction failure without rollback (fixed 2025-11-04)"
      ]
    },
    "SSEEventType": {
      "file": "/frontend/src/hooks/useSSE.ts",
      "type": "enum",
      "purpose": "Type-safe event names for Server-Sent Events subscription system",
      "values": {
        "SYSTEM_STATUS": "System-wide status updates",
        "FIGHT_STATUS_UPDATE": "Fight status transitions (upcoming â†’ betting â†’ live â†’ completed)",
        "NEW_BET": "New bet created and available for matching",
        "BET_MATCHED": "PAGO/DOY bet successfully matched between users",
        "BET_CANCELLED": "Bet cancelled by user or system",
        "BET_SETTLED": "Fight completed, bet result determined",
        "PAGO_PROPOSAL": "PAGO bet proposal created (3-minute timeout)",
        "DOY_PROPOSAL": "DOY acceptance of PAGO proposal",
        "BETTING_WINDOW_OPENED": "Fight entered betting status",
        "BETTING_WINDOW_CLOSED": "Fight exited betting status (no new bets)",
        "WALLET_UPDATE": "User wallet balance changed"
      },
      "critical_fix_2025_11_04": {
        "issue": "BettingPanel used string literals instead of enum for subscribe()",
        "fix_location": "frontend/src/components/user/BettingPanel.tsx:56-65",
        "wrong_pattern": "subscribe('NEW_BET', callback) // String literal - BROKEN",
        "correct_pattern": "subscribe(SSEEventType.NEW_BET, callback) // Enum - CORRECT",
        "validation": "TypeScript compilation ZERO errors after fix"
      },
      "usage_pattern": {
        "import": "import { useFightSSE, SSEEventType } from '../../hooks/useSSE'",
        "subscription": "const unsubscribe = subscribe(SSEEventType.NEW_BET, (event) => { handleNewBet(event); })",
        "cleanup": "useEffect(() => { const cleanup = subscribe(...); return () => cleanup(); }, [deps])",
        "type_safety": "TypeScript enforces enum usage, prevents typos in event names"
      },
      "component_examples": {
        "BettingPanel": {
          "file": "frontend/src/components/user/BettingPanel.tsx",
          "subscriptions": [
            "SSEEventType.NEW_BET - Refresh available bets list",
            "SSEEventType.BET_MATCHED - Trigger onBetPlaced callback"
          ],
          "line_references": "Lines 56, 65 (fixed 2025-11-04)"
        }
      }
    },
    "MembershipChangeRequest": {
      "file": "/backend/src/models/MembershipChangeRequest.ts",
      "required_properties": ["id", "userId", "requestedMembershipType", "status", "createdAt"],
      "optional_properties": ["requestNotes", "paymentProofUrl", "completedAt", "completedBy", "rejectionReason"],
      "status_enum": ["pending", "completed", "rejected"],
      "membership_type_enum": ["24-hour", "monthly"],
      "business_rules": [
        "User must have registered phone number to create request",
        "Only one pending request allowed per user at a time",
        "Cannot request if user already has active subscription (must wait for expiration)",
        "Cannot request 'free' tier (automatically assigned on expiration/cancellation)",
        "Admin/operator can complete or reject requests",
        "Payment proof URL is optional but recommended"
      ],
      "frontend_integration": {
        "user_component": "/frontend/src/components/user/MembershipSection.tsx",
        "admin_component": "/frontend/src/components/admin/SubscriptionTabs.tsx",
        "api_service": "/frontend/src/services/api.ts (membershipRequestsAPI)"
      },
      "api_endpoints": {
        "create": "POST /api/membership-requests",
        "my_requests": "GET /api/membership-requests/my-requests",
        "pending": "GET /api/membership-requests/pending (admin/operator only)",
        "complete": "PATCH /api/membership-requests/:id/complete (admin/operator only)",
        "reject": "PATCH /api/membership-requests/:id/reject (admin/operator only)"
      },
      "validation_rules": {
        "requestedMembershipType": "Required, must be '24-hour' or 'monthly'",
        "requestNotes": "Optional, max 1000 characters",
        "paymentProofUrl": "Optional, max 500 characters, must be valid URL format",
        "rejectionReason": "Required when rejecting, max 500 characters"
      },
      "common_errors": [
        "Using 'type' instead of 'requestedMembershipType' field",
        "Attempting to request 'free' tier (not allowed)",
        "Creating duplicate pending request (one per user limit)",
        "Missing phone number in user profile"
      ]
    },
    "EventConnection": {
      "file": "/backend/src/models/EventConnection.ts",
      "purpose": "Track user connections to events for real-time viewer count and historical analytics",
      "required_properties": ["id", "event_id", "user_id", "session_id", "connected_at"],
      "optional_properties": ["disconnected_at", "duration_seconds", "ip_address", "user_agent"],
      "database_table": "event_connections",
      "indexes": [
        "idx_event_connections_event_disconnected (event_id, disconnected_at) - For fast viewer queries"
      ],
      "field_descriptions": {
        "id": "number - Primary key, auto-increment",
        "event_id": "number - Foreign key to events table",
        "user_id": "number - Foreign key to users table",
        "session_id": "string - Unique session identifier",
        "connected_at": "Date - Timestamp when user connected",
        "disconnected_at": "Date | null - Timestamp when user disconnected (null if still connected)",
        "duration_seconds": "number | null - Total connection duration in seconds",
        "ip_address": "string | null - User IP address for security auditing",
        "user_agent": "string | null - Browser/device information"
      },
      "usage_scenarios": [
        "Real-time viewer count: Count where disconnected_at IS NULL",
        "Historical analytics: Aggregate data with user joins",
        "Security auditing: Track unusual connection patterns",
        "Performance metrics: Average watch time per event"
      ],
      "api_endpoints": {
        "get_viewers": "GET /api/events/:id/viewers - Real-time viewer count",
        "get_analytics": "GET /api/events/:id/analytics - Historical connection data with user details"
      },
      "automatic_tracking": {
        "connection": "Tracked via streamingSocket.trackConnection() in backend/src/sockets/streamingSocket.ts:8",
        "disconnection": "Tracked via streamingSocket.trackDisconnection() in backend/src/sockets/streamingSocket.ts:22",
        "duration_calculation": "Auto-calculated on disconnection: (disconnected_at - connected_at) / 1000"
      },
      "business_value": [
        "Monitor event popularity in real-time",
        "Identify most popular events/times",
        "Detect account sharing (multiple concurrent connections)",
        "Calculate average engagement per event",
        "Security: Track suspicious connection patterns"
      ]
    },
    "EventData": {
      "file": "/frontend/src/types/index.ts",
      "union_types": {
        "operator": "string | { username: string }",
        "status": "upcoming | live | completed | cancelled | betting | in-progress | scheduled | paused | intermission"
      },
      "status_enum_optimization_2025_11_19": {
        "added_status": "paused (NEW) - Explicit pause state for streaming bandwidth optimization",
        "description": "When pauseStream endpoint is called, event.status changes to 'paused' (was 'intermission')",
        "rationale": "Distinguish explicit pause from between-fights context",
        "backend_model": "Event.ts - status union includes 'paused' alongside existing values"
      },
      "required_properties": ["id", "name", "status", "venue", "createdAt", "updatedAt", "venueId"],
      "recently_added": ["streamKey", "currentViewers", "activeBets", "completedFights", "totalFights", "totalPrizePool", "streamStatus", "fights"],
      "venue_structure": {
        "fase_5_2025_11_05": "venue object now includes optional profileInfo field for consolidated architecture",
        "required_fields": ["id", "name"],
        "optional_fields": ["location", "profileInfo"],
        "profileInfo_fields": ["venueName", "venueLocation", "venueDescription", "venueEmail", "venueWebsite", "images"],
        "access_pattern": "event.venue?.profileInfo?.venueName || event.venue?.name || 'Venue TBD'",
        "backend_response": "Venue data comes from User.profileInfo (single source of truth post-FASE 5 consolidation)",
        "note": "profileInfo field added 2025-11-05 to support FASE 5 consolidated architecture where venues exist as User records with role='venue'"
      }
    },
    "Venue": {
      "file": "/frontend/src/types/index.ts",
      "deprecated": "ðŸ”´ 2025-10-30 CRITICAL: venues table ELIMINATED. Venue data now in User.profileInfo",
      "note_2025_10_30": "GET /venues returns User objects (role='venue'), NOT Venue objects. Frontend MUST access profileInfo for venue details.",
      "api_endpoint_note": "ðŸ”´ CHANGED 2025-10-30: GET /venues now returns User.findAndCountAll({role:'venue'}) with data in profileInfo (venueName, venueLocation, venueDescription, etc). NO venues table exists.",
      "response_structure": {
        "users": [
          {
            "id": "UUID (user.id)",
            "username": "string",
            "email": "string",
            "role": "'venue'",
            "approved": "boolean",
            "profileInfo": {
              "venueName": "string (was venue.name)",
              "venueLocation": "string (was venue.location)",
              "venueDescription": "string (was venue.description)",
              "venueEmail": "string",
              "venueWebsite": "string",
              "businessName": "string"
            },
            "images": "string[] | null"
          }
        ]
      },
      "frontend_migration": "Replace venue.name â†’ user.profileInfo.venueName, venue.location â†’ user.profileInfo.venueLocation, etc"
    },
    "Article": {
      "file": "/frontend/src/types/article.ts",
      "required_properties": ["id", "title", "slug", "content", "status", "created_at"],
      "optional_properties": ["excerpt", "featured_image", "published_at", "author", "admin_rejection_message"],
      "admin_rejection_message": {
        "type": "string | undefined",
        "description": "Admin feedback message when article is rejected",
        "when_present": "Article status = 'draft' AND was previously rejected by admin",
        "display_location": "ArticleEditor.tsx - red alert box at top of modal",
        "backend_field": "articles.admin_rejection_message (TEXT, nullable)",
        "validation": "10-500 characters (enforced on reject endpoint)",
        "created": "2025-11-22 via ARTICLE_ADMIN_WORKFLOW task"
      },
      "fase_5_note": "venue_id REMOVED (2025-11-07) per PRD:205 - Articles use ONLY author_id",
      "backend_auto_generated": ["slug"],
      "slug_generation": {
        "source": "Generated from title field",
        "format": "URL-friendly (lowercase, hyphens, no special chars)",
        "uniqueness": "Enforced by backend with automatic numbering",
        "frontend_note": "NEVER send slug field - backend auto-generates"
      },
      "status_enum_and_visibility": {
        "last_updated": "2025-11-22",
        "status_values": ["draft", "pending", "published", "archived"],
        "visibility_filtering_by_role": {
          "admin_and_operator": {
            "description": "Full visibility - see articles in requested status",
            "logic": "WHERE status = ? (status parameter or default 'published')",
            "use_case": "Admin panel article management"
          },
          "authenticated_user": {
            "description": "Own articles (any status) + published from others",
            "logic": "WHERE (author_id = userId AND status IN [draft, pending, published, archived]) OR (author_id != userId AND status = 'published')",
            "use_case": "User dashboard showing their articles and published content"
          },
          "guest_anonymous": {
            "description": "Only published articles",
            "logic": "WHERE status = 'published'",
            "use_case": "Public article listing"
          }
        },
        "important_notes": [
          "status parameter is optional - defaults to 'published' for non-admin users",
          "When user explicitly requests status=draft/pending, they only see their own articles in that status",
          "Non-admin users cannot see draft/pending/archived articles from other users",
          "Implement via backend/src/routes/articles.ts lines 136-189"
        ]
      }
    },
    "Gallera": {
      "file": "/frontend/src/types/index.ts",
      "deprecated": "ðŸ”´ 2025-10-30 CRITICAL: galleras table ELIMINATED. Gallera data now in User.profileInfo",
      "note_2025_10_30": "GET /galleras returns User objects (role='gallera'), NOT Gallera objects. Frontend MUST access profileInfo for gallera details.",
      "api_endpoint_note": "ðŸ”´ CHANGED 2025-10-30: GET /galleras now returns User.findAndCountAll({role:'gallera'}) with data in profileInfo (galleraName, galleraLocation, galleraDescription, etc). NO galleras table exists.",
      "response_structure": {
        "users": [
          {
            "id": "UUID (user.id)",
            "username": "string",
            "email": "string",
            "role": "'gallera'",
            "approved": "boolean",
            "profileInfo": {
              "galleraName": "string (was gallera.name)",
              "galleraLocation": "string (was gallera.location)",
              "galleraDescription": "string (was gallera.description)",
              "galleraEmail": "string",
              "galleraWebsite": "string",
              "galleraSpecialties": "string | object (was specialties)",
              "galleraActiveRoosters": "number (was activeRoosters)",
              "businessName": "string"
            },
            "images": "string[] | null"
          }
        ]
      },
      "frontend_migration": "Replace gallera.name â†’ user.profileInfo.galleraName, gallera.location â†’ user.profileInfo.galleraLocation, etc",
      "common_errors": [
        "âŒ NEVER access venue or gallera table directly - tables don't exist",
        "âŒ NEVER destructure response.data.venues/galleras - it returns response.data.users",
        "âœ… Always access profileInfo fields: user.profileInfo.galleraName, user.profileInfo.venueName, etc"
      ]
    },
    "UserProfileWithSubscription": {
      "file": "/frontend/src/types/index.ts",
      "integration": "Primary interface for user profile with subscription integration",
      "composition": {
        "extends": "User interface",
        "additional_field": "subscription: UserSubscription object",
        "usage_location": "GET /api/users/profile response includes both user data and current subscription status"
      },
      "frontend_utility": {
        "access_pattern": "response.data.user for user info and response.data.subscription for subscription status",
        "subscription_check": "Frontend components use both user.profileInfo.verificationLevel and subscription.status to determine access permissions",
        "premium_content_logic": "Premium content access requires BOTH verified account AND active subscription"
      },
      "response_structure": {
        "success": true,
        "data": {
          "user": "User object with profileInfo",
          "subscription": "UserSubscription object with status and expiration"
        }
      },
      "expiration_handling": {
        "automatic_update": "Frontend components automatically update access controls when subscription expires",
        "visual_feedback": "Premium indicators automatically hide when subscription is no longer active",
        "navigation_adjustment": "Menu items adjust automatically based on current subscription status"
      }
    },
    "Transaction": {
      "file": "/backend/src/models/Transaction.ts (inferred)",
      "purpose": "Type definition for all financial transactions in the system",
      "required_properties": ["id", "walletId", "type", "amount", "status"],
      "optional_properties": ["description", "metadata", "createdAt", "updatedAt"],
      "interface": {
        "id": "string - UUID of transaction",
        "walletId": "string - UUID of associated wallet",
        "type": "'deposit' | 'withdrawal' | 'bet-win' | 'bet-loss' | 'bet-refund' | 'admin_credit' | 'admin_debit' - transaction type",
        "amount": "number - amount of transaction",
        "status": "'pending' | 'completed' | 'failed' - status of transaction",
        "description": "string (optional) - human-readable description",
        "metadata": "object (optional) - additional data (e.g., walletOperationId, adminId, reason)",
        "createdAt": "Date",
        "updatedAt": "Date"
      },
      "type_enum": [
        "deposit",
        "withdrawal",
        "bet-win",
        "bet-loss",
        "bet-refund",
        "admin_credit",
        "admin_debit"
      ],
      "type_enum_note": "admin_credit and admin_debit added 2025-12-02 for admin manual balance adjustments",
      "status_enum": [
        "pending",
        "completed",
        "failed"
      ],
      "implementation_note": "Used to track all financial movements in user wallets for audit and history.",
      "added_date": "2025-12-02"
    }
  },

  "wallet_and_financial_interfaces": {
    "Wallet": {
      "file": "/backend/src/models/Wallet.ts",
      "purpose": "Core wallet model for user balance management with frozen funds support",
      "required_properties": ["id", "userId", "balance", "frozenAmount", "createdAt", "updatedAt"],
      "interface": {
        "id": "string - UUID of wallet",
        "userId": "string - UUID of wallet owner",
        "balance": "DECIMAL(12,2) - Total wallet balance (CRITICAL: stored as string in PostgreSQL)",
        "frozenAmount": "DECIMAL(12,2) - Locked funds from active bets (CRITICAL: stored as string in PostgreSQL)",
        "createdAt": "Date",
        "updatedAt": "Date"
      },
      "critical_postgresql_behavior": {
        "issue": "PostgreSQL DECIMAL(12,2) columns return strings ('150.00'), NOT numbers in Sequelize",
        "impact": "Direct arithmetic operations fail: wallet.balance.toFixed() throws 'not a function' error",
        "solution": "ALL backend code uses parseFloat(String(value)) pattern before arithmetic",
        "added_date": "2025-12-05"
      },
      "instance_methods": {
        "getAvailableBalance": {
          "returns": "number - balance minus frozenAmount",
          "implementation": "parseFloat(String(this.balance)) - parseFloat(String(this.frozenAmount))",
          "purpose": "Calculate spendable balance excluding locked funds from active bets"
        },
        "toPublicJSON": {
          "returns": "{ balance: number, frozenAmount: number, availableBalance: number, updatedAt: Date }",
          "implementation": "Converts PostgreSQL DECIMAL strings to JavaScript numbers",
          "critical": "MUST use parseFloat(String()) for each DECIMAL field before returning"
        }
      },
      "frozen_amount_logic": {
        "purpose": "Lock funds when bets become active, prevent over-spending",
        "workflow": {
          "pending_bet": "frozenAmount NOT updated (user can still bet with that money)",
          "active_bet": "frozenAmount += bet_amount (money locked until fight settles)",
          "completed_win": "frozenAmount -= bet_amount, balance += (bet_amount + winnings - 5% commission)",
          "completed_loss": "frozenAmount -= bet_amount (money already transferred to winner)",
          "cancelled": "frozenAmount -= bet_amount, balance += bet_amount (return money)"
        },
        "admin_debit_validation": "CRITICAL: Admin balance debit checks available balance (balance - frozenAmount), not total balance"
      },
      "backend_usage_pattern": {
        "all_arithmetic": "const balance = parseFloat(String(wallet.balance)); const frozen = parseFloat(String(wallet.frozenAmount));",
        "response_serialization": "Use wallet.toPublicJSON() to send numeric values to frontend",
        "frontend_defensive": "Frontend should use parseFloat(String()) as fallback for safety"
      },
      "common_errors": [
        "wallet.balance.toFixed() - FAILS because balance is string",
        "wallet.balance + amount - FAILS (string concatenation instead of addition)",
        "balance - frozenAmount without parseFloat - FAILS with NaN or wrong result"
      ],
      "implementation_files": [
        "backend/src/models/Wallet.ts:37-41 (getAvailableBalance)",
        "backend/src/models/Wallet.ts:89-93 (toPublicJSON)",
        "backend/src/routes/users.ts:1042-1064 (adjust-balance with parseFloat)",
        "frontend/src/components/admin/UserModal.tsx:633 (defensive parseFloat)"
      ],
      "added_date": "2025-12-05"
    },
    "WalletOperation": {
      "file": "/frontend/src/types/walletOperation.ts",
      "backend_model": "/backend/src/models/WalletOperation.ts",
      "purpose": "Type definition for wallet deposit/withdrawal operations with admin approval workflow",
      "required_properties": ["id", "userId", "walletId", "type", "amount", "status", "createdAt"],
      "optional_properties": ["paymentProofUrl", "adminProofUrl", "adminNotes", "rejectionReason", "processedBy", "completedAt", "requestedAt"],
      "interface": {
        "id": "string - UUID of wallet operation",
        "userId": "string - UUID of user requesting operation",
        "walletId": "string - UUID of wallet affected",
        "type": "'deposit' | 'withdrawal' - operation type",
        "amount": "number - operation amount",
        "status": "'pending' | 'approved' | 'rejected' | 'cancelled' | 'completed' - operation status",
        "paymentProofUrl": "string (optional) - user uploaded bank transfer screenshot URL",
        "adminProofUrl": "string (optional) - admin uploaded transfer receipt URL",
        "adminNotes": "string (optional) - admin comments about operation",
        "rejectionReason": "string (optional) - reason when status=rejected",
        "processedBy": "string (optional) - UUID of admin who processed",
        "completedAt": "Date (optional) - when operation completed",
        "requestedAt": "Date - when operation was requested",
        "createdAt": "Date",
        "updatedAt": "Date"
      },
      "status_workflow": {
        "deposit": "pending â†’ (admin approval) â†’ approved â†’ (balance update) â†’ completed",
        "withdrawal": "pending â†’ (admin uploads proof) â†’ approved â†’ (balance deduction) â†’ completed",
        "rejection": "pending â†’ rejected (with rejectionReason)",
        "cancellation": "pending â†’ cancelled (by user or admin)"
      },
      "validation_rules": {
        "deposit": [
          "amount >= wallet.deposit_min (default $5)",
          "amount <= wallet.deposit_max (default $1000/tx)",
          "daily total + amount <= wallet.deposit_max_daily (default $5000)",
          "if amount > wallet.require_proof_over ($50), paymentProofUrl required"
        ],
        "withdrawal": [
          "amount >= wallet.withdrawal_min (default $10)",
          "amount <= wallet.withdrawal_max (default $500/tx)",
          "amount <= user.wallet.balance",
          "daily total + amount <= wallet.withdrawal_max_daily (default $2000)",
          "adminProofUrl MANDATORY before admin can approve"
        ]
      },
      "transaction_safety": "All approval operations use DB transactions with rollback on error",
      "implementation_date": "2025-11-24 (Finance administration system)"
    },
    "SystemSetting": {
      "file": "/frontend/src/types (inferred from backend)",
      "backend_model": "/backend/src/models/SystemSetting.ts (inferred)",
      "backend_service": "/backend/src/services/systemSettingsService.ts",
      "purpose": "Type definition for universal system configuration settings with Redis caching",
      "required_properties": ["key", "value", "type", "category"],
      "optional_properties": ["description", "isPublic", "updatedBy"],
      "interface": {
        "key": "string - unique setting key (e.g., 'wallet.deposit_max', 'betting.commission_rate')",
        "value": "any - JSONB value allowing complex objects",
        "type": "'number' | 'string' | 'boolean' | 'array' | 'object' - data type hint",
        "category": "'wallets' | 'betting' | 'streaming' | 'cache' | 'security' | 'notifications' | 'system' | 'limits' | 'performance' | 'business' | 'features'",
        "description": "string (optional) - human-readable explanation",
        "isPublic": "boolean (optional) - whether non-admin users can read this setting",
        "updatedBy": "string (optional) - UUID of user who last updated setting",
        "createdAt": "Date - when setting was created",
        "updatedAt": "Date - when setting was last updated"
      },
      "categories": {
        "wallets": "Deposit/withdrawal limits and rules",
        "betting": "Bet limits, commission, timeout, rules",
        "streaming": "Max connections, heartbeat intervals, HLS config",
        "cache": "Redis TTL values for different entities",
        "security": "Session lifetime, login attempts, password rules",
        "notifications": "Email/push notification configuration",
        "system": "Maintenance mode, timezone, currency, support contacts",
        "limits": "Upload limits, resource constraints",
        "performance": "DB pool size, rate limits, query timeouts",
        "business": "Subscription pricing, commission rates, referral bonuses",
        "features": "Feature flags (enable/disable platform features)"
      },
      "example_settings": {
        "wallet.deposit_max": "{\"amount\": 1000} - Max deposit per transaction",
        "betting.commission_rate": "{\"rate\": 0.05} - 5% commission from winner",
        "streaming.max_connections_per_user": "{\"count\": 2} - Max concurrent connections",
        "cache.users_ttl_seconds": "{\"ttl\": 300} - User cache TTL (5 min)",
        "security.session_lifetime_hours": "{\"hours\": 168} - Session lifetime (7 days)",
        "features.betting_enabled": "{\"enabled\": true} - Enable/disable betting",
        "system.maintenance_mode": "{\"enabled\": false} - Maintenance mode flag"
      },
      "redis_caching": {
        "ttl": "300 seconds (5 minutes)",
        "cache_key_pattern": "system_setting:{key} or system_settings:category:{category}",
        "invalidation": "Cache invalidated automatically on setting update"
      },
      "frontend_usage": [
        "frontend/src/pages/admin/Settings.tsx - Admin UI for managing settings"
      ],
      "backend_endpoints": [
        "GET /api/settings - Get all settings grouped by category (admin only)",
        "GET /api/settings/category/:category - Get settings for specific category (admin only)",
        "GET /api/settings/public - Get public settings (authenticated users)",
        "PUT /api/settings/:key - Update single setting value (admin only)"
      ],
      "implementation_date": "2025-11-24 (Universal configuration system)"
    }
  },

  "betting_system_interfaces": {
    "Bet_PAGO_DOY_Enhanced": {
      "file": "/frontend/src/types/index.ts (Bet interface)",
      "backend_model": "/backend/src/models/Bet.ts",
      "purpose": "Enhanced Bet interface with PAGO/DOY betting support for P2P betting",
      "enhancement_date": "2025-11-24",
      "new_properties": {
        "betType": "'flat' | 'doy' | 'pago' - Bet type (was missing 'pago' before)",
        "terms": {
          "pagoAmount": "number (optional) - Amount for PAGO counter-offer",
          "doyAmount": "number (optional) - Amount for DOY advantage offer",
          "ratio": "number (optional) - DOY ratio calculation",
          "isOffer": "boolean (optional) - Whether bet is an offer",
          "proposedBy": "string (optional) - UUID of user who proposed PAGO"
        },
        "proposalStatus": "'none' | 'pending' | 'accepted' | 'rejected' - PAGO proposal status",
        "matchedWith": "string (optional) - UUID of matched bet",
        "parentBetId": "string (optional) - UUID of parent bet (for PAGO proposals)"
      },
      "bet_types_explained": {
        "flat": "Symmetric bet: $50 vs $50. Can auto-match if counterpart exists.",
        "doy": "Advantage offer: Win $40, Lose $50. Manual accept only.",
        "pago": "Counter-offer: Pay $40 if lose, Collect $50 if win. Requires original bettor acceptance."
      },
      "bet_statuses": {
        "pending": "Created, editable, visible in suggestions. frozen_amount NOT locked yet.",
        "pending_pago": "PAGO proposal sent, waiting for original bettor accept/reject.",
        "active": "Confirmed by both, frozen_amount locked. NOT editable.",
        "completed": "Fight finished, result applied, frozen_amount released/transferred.",
        "cancelled": "Cancelled before match by user or system."
      },
      "frozen_amount_logic": {
        "pending_bet": "frozen_amount NOT updated (user can still bet with that money)",
        "active_bet": "frozen_amount += bet_amount (money locked until fight settles)",
        "completed_win": "frozen_amount -= bet_amount, balance += (bet_amount + winnings - 5% commission)",
        "completed_loss": "frozen_amount -= bet_amount (money already transferred to winner)",
        "cancelled": "frozen_amount -= bet_amount, balance += bet_amount (return money)",
        "draw": "frozen_amount -= bet_amount, balance += bet_amount (return money)"
      },
      "business_rules": {
        "commission": "5% from winner only. Example: Win $50 â†’ collect $47.50 (50 - 2.50).",
        "editable": "Only if status=pending. If active, locked forever.",
        "multiple_bets": "User can have multiple active bets in same event/fight.",
        "auto_match": "ONLY flat bets. DOY and PAGO require manual acceptance."
      },
      "frontend_components": [
        "frontend/src/components/betting/BetSuggestionsPanel.tsx - Show compatible bets while typing",
        "frontend/src/components/betting/EditBetModal.tsx - Edit pending bets",
        "frontend/src/components/betting/PagoProposalBadge.tsx - PAGO status indicator",
        "frontend/src/components/betting/AcceptPagoModal.tsx - Accept/reject PAGO"
      ],
      "backend_endpoints": [
        "GET /api/bets/suggestions - Query pending opposite bets Â±20% range",
        "PUT /api/bets/:id/edit - Edit pending bet (status=pending only)",
        "POST /api/bets/:id/propose-pago - Create PAGO proposal",
        "PUT /api/bets/:id/accept-pago - Match both bets, lock frozen_amounts",
        "PUT /api/bets/:id/reject-pago - Reject PAGO proposal",
        "POST /api/bets - Enhanced with auto-match for flat bets"
      ]
    }
  },

  "frontend_component_interfaces": {
    "ImageGalleryUpload": {
      "file": "/frontend/src/components/shared/ImageGalleryUpload.tsx",
      "component_name": "ImageGalleryUpload",
      "purpose": "Reusable multi-image upload component with gallery grid display",
      "props": {
        "images": "string[] (required) - Array of image URLs",
        "onImagesChange": "(images: string[]) => void (required) - Callback when images array changes",
        "maxImages": "number (optional, default: 10) - Maximum number of images allowed",
        "label": "string (optional, default: 'GalerÃ­a de ImÃ¡genes') - Component label"
      },
      "features": [
        "Multiple image upload support",
        "Grid display of uploaded images (2-4 columns responsive)",
        "Individual image deletion with hover action",
        "Loading state during upload",
        "File type validation (image/* only)",
        "File size validation (max 5MB per image)",
        "Error handling per image with user feedback",
        "Image counter showing used/max images"
      ],
      "usage_examples": [
        "UnifiedEntityForm.tsx: Manages venue/gallera images gallery (REPLACES VenueEntityForm + GalleraEntityForm) - UPDATED 2025-11-04",
        "CreateUserModal.tsx: Role-based image upload (venue maxImages=2, gallera maxImages=3) - ADDED 2025-10-31",
        "EditVenueGalleraModal.tsx: Entity Info tab image management - ADDED 2025-10-31",
        "Supports ARRAY(string) database fields",
        "ðŸ”´ DEPRECATED: VenueEntityForm.tsx.deprecated, GalleraEntityForm.tsx.deprecated (replaced by UnifiedEntityForm 2025-11-04)"
      ],
      "validation": {
        "file_type": "file.type.startsWith('image/')",
        "file_size": "max 5MB (5 * 1024 * 1024)",
        "max_images": "Configurable, default 10"
      },
      "api_integration": "Uses uploadsAPI.uploadImage(file) for server upload",
      "styling": "TailwindCSS with Lucide React icons (Camera, X, Loader)"
    },
    "UnifiedEntityForm": {
      "file": "/frontend/src/components/forms/UnifiedEntityForm.tsx",
      "purpose": "ðŸ”´ FASE 5: Unified form component for venue/gallera profile management, replaces VenueEntityForm + GalleraEntityForm (75% code reduction)",
      "interface": "UnifiedEntityFormProps",
      "required_properties": {
        "entityType": "'venue' | 'gallera' - Determines which fields to render",
        "userId": "string - ID of user whose profileInfo will be updated",
        "onSuccess": "(updatedUser: User) => void - Callback after successful save",
        "onCancel": "() => void - Callback when user cancels"
      },
      "optional_properties": {
        "initialData": "Record<string, any> - Pre-populate form with user.profileInfo data"
      },
      "architecture": {
        "consolidation_pattern": "Single component with conditional field rendering based on entityType",
        "api_call": "usersAPI.updateProfileInfo(userId, profileInfoUpdate)",
        "replaces": "Deprecated venuesAPI.update() and gallerasAPI.update() calls",
        "code_metrics": {
          "old_approach": "VenueEntityForm (248 lines) + GalleraEntityForm (363 lines) = 611 lines",
          "new_approach": "UnifiedEntityForm (321 lines) = 75% code reduction",
          "shared_logic": "Business name, location, description, email, website, images (common fields)",
          "entity_specific": "galleraSpecialties, galleraActiveRoosters (only for gallera)"
        }
      },
      "field_mapping": {
        "venue": ["venueName (businessName)", "venueLocation", "venueDescription", "venueEmail", "venueWebsite", "images (max 2)"],
        "gallera": ["galleraName (businessName)", "galleraLocation", "galleraDescription", "galleraEmail", "galleraWebsite", "galleraSpecialties", "galleraActiveRoosters", "images (max 3)"]
      },
      "usage_example": "<UnifiedEntityForm entityType=\"venue\" userId={user.id} initialData={user.profileInfo} onSuccess={handleSave} onCancel={handleCancel} />",
      "integration": {
        "parent_component": "Profile.tsx (lines 261-267)",
        "usage_context": "When venue/gallera user edits business information",
        "data_flow": "user.profileInfo â†’ form fields â†’ usersAPI.updateProfileInfo() â†’ refreshUser()"
      },
      "added_date": "2025-11-04 (FASE 5 consolidation)"
    },
    "OptimizedStreamingMonitor": {
      "file": "/frontend/src/pages/admin/OptimizedStreamingMonitor.tsx (NEW)",
      "purpose": "Unified streaming + monitoring page (consolidated from Streaming.tsx + Monitoring.tsx)",
      "added_date": "2025-11-19 (UNIFIED_STREAMING_MONITORING_IMPLEMENTATION)",
      "layout": {
        "top": "Event selector + stream status indicator (green=live, red=offline)",
        "left_70_percent": "HLS stream player + stream controls (play/pause/info)",
        "right_30_percent": "Live metrics card: { connectionCount, activeBets }"
      },
      "data_source": "useSSEConnection hook",
      "props": {
        "none": "Uses auth context for token and route params for event selection"
      },
      "dependencies": {
        "useSSEConnection": "Real-time metrics via SSE",
        "HLSPlayer": "Stream playback component (from existing Streaming.tsx)",
        "useAuth": "Token retrieval for SSE connection"
      },
      "performance": "Single EventSource connection = 98.4% reduction vs polling (30 events/min vs 48 requests/min)"
    }
  },

  "hook_interfaces": {
    "useSSEConnection": {
      "file": "/frontend/src/hooks/useSSEConnection.ts (NEW)",
      "purpose": "Manage Server-Sent Events connection to /api/sse/streaming endpoint with auto-reconnect",
      "added_date": "2025-11-19 (UNIFIED_STREAMING_MONITORING_IMPLEMENTATION)",
      "return_structure": {
        "connectionCount": "number - Active streaming viewers",
        "activeBets": "number - Active bets awaiting settlement",
        "streamStatus": "{ isLive: boolean } - Current stream status",
        "isConnected": "boolean - Whether SSE connection is active",
        "error": "Error | null - Last connection error"
      },
      "behavior": {
        "onmount": "Opens EventSource connection to /api/sse/streaming?token=jwt",
        "onmessage": "Parses JSON data from server and updates state",
        "onerror": "Sets isConnected=false, closes connection, triggers reconnect after exponential backoff",
        "onunmount": "Closes EventSource connection gracefully"
      },
      "reconnect_strategy": "Exponential backoff: 1s â†’ 2s â†’ 4s â†’ 8s (max 30s)",
      "token_source": "localStorage.getItem('token') - Must be valid JWT",
      "critical_note": "âš ï¸ EventSource cannot send custom headers. Token MUST be passed via query parameter."
    },
    "useUserForm": {
      "file": "/frontend/src/hooks/useUserForm.ts",
      "purpose": "Centralize form state management for create/edit modes",
      "parameters": ["mode: 'create' | 'edit'", "role: 'operator' | 'venue' | 'gallera' | 'user'", "initialUser?: User"],
      "returns": ["formData", "handleChange", "handleArrayChange", "handleImagesChange", "handleSubmit", "error"],
      "handleChange_enhancement": "Supports nested field names with dot notation (e.g., 'profileInfo.fullName')"
    },
    "useUserSubscription": {
      "file": "/frontend/src/hooks/useUserSubscription.ts",
      "purpose": "Centralize subscription management logic",
      "parameters": ["userId: string", "initialSubscription?: UserSubscription"],
      "returns": ["subscription", "isUpdating", "updateSubscription"]
    }
  },

  "feature_flag_interfaces": {
    "FeatureFlags": {
      "file": "/frontend/src/hooks/useFeatureFlags.ts",
      "purpose": "Type definition for feature flags that control UI visibility and functionality",
      "required_properties": ["isBettingEnabled", "isWalletEnabled", "isStreamingEnabled", "isArticlesEnabled", "isAdsEnabled"],
      "interface": {
        "isBettingEnabled": "boolean - Controls betting functionality access and UI visibility",
        "isWalletEnabled": "boolean - Controls wallet functionality access and UI visibility",
        "isStreamingEnabled": "boolean - Controls streaming functionality access and UI visibility",
        "isArticlesEnabled": "boolean - Controls articles functionality access and UI visibility (currently environment-controlled)",
        "isAdsEnabled": "boolean - Controls advertisements functionality access and UI visibility (currently environment-controlled)"
      },
      "data_source": {
        "dynamic_flags": ["isBettingEnabled", "isWalletEnabled", "isStreamingEnabled", "isPushNotificationsEnabled"],
        "source": "GET /api/settings/features/public endpoint (reads from system_settings database with enable_* keys)",
        "processing": "Hook fetches from API and maps betting_enabled â†’ isBettingEnabled, wallets_enabled â†’ isWalletEnabled, etc."
      },
      "data_source_static": {
        "static_flags": ["isArticlesEnabled", "isAdsEnabled"],
        "source": "Environment variables (VITE_FEATURES_ARTICLES, VITE_FEATURES_ADS)",
        "reason": "These flags are not yet implemented in database settings system"
      },
      "frontend_usage": [
        "frontend/src/components/user/Navigation.tsx - Conditionally renders Wallet/Betting links",
        "frontend/src/components/user/UserHeader.tsx - Shows wallet balance and betting access",
        "frontend/src/pages/user/Dashboard.tsx - Shows/hides betting features based on isBettingEnabled",
        "frontend/src/pages/user/Bets.tsx - Shows/hides betting interface based on isBettingEnabled",
        "frontend/src/pages/user/Wallet.tsx - Shows/hides wallet interface based on isWalletEnabled"
      ],
      "feature_flag_mapping": {
        "backend_key_to_frontend_property": {
          "enable_betting": "isBettingEnabled",
          "enable_wallets": "isWalletEnabled",
          "enable_streaming": "isStreamingEnabled",
          "enable_push_notifications": "isPushNotificationsEnabled (hypothetical)"
        }
      },
      "implementation_date": "2025-12-01 (feature flag unification - migrated from *.active to enable_* keys in database)",
      "update_reason": "Feature flag system unification to eliminate redundancy between enable_* and *.active fields"
    }
  },

  "backend_type_extensions": {
    "express_request_extensions": {
      "file": "/backend/src/types/express.d.ts",
      "purpose": "Extend Express Request interface for session management",
      "properties_added": {
        "user": {
          "type": "User (from models)",
          "optional": true,
          "added_by": "Authentication middleware",
          "usage": "Access authenticated user in request handlers"
        },
        "sessionToken": {
          "type": "string",
          "optional": true,
          "added_by": "enhancedAuthenticate middleware",
          "usage": "JWT token for session invalidation on logout"
        }
      },
      "implementation_pattern": {
        "declaration": "declare global { namespace Express { interface Request { user?: User; sessionToken?: string; } } }",
        "export": "export {}; // Required for module augmentation",
        "usage_example": "req.user.id // Available after authentication"
      },
      "critical_notes": [
        "MUST use 'declare global' for Express augmentation",
        "MUST export {} for TypeScript module system",
        "MUST import User type from models",
        "Properties are optional (added by middleware)"
      ],
      "related_middleware": [
        "/backend/src/middleware/enhancedAuth.ts - Sets req.user and req.sessionToken",
        "/backend/src/middleware/auth.ts - Legacy auth (sets req.user only)"
      ]
    },
    "redis_client_interface": {
      "file": "/backend/src/config/redis.ts",
      "class": "SafeRedisClient",
      "purpose": "Type-safe Redis client wrapper with fallback cache",
      "public_methods": {
        "get": "async get(key: string): Promise<string | null>",
        "set": "async set(key: string, value: string, ttl: number = 300): Promise<void>",
        "setex": "async setex(key: string, ttl: number, value: string): Promise<void> // Legacy alias",
        "del": "async del(pattern: string): Promise<void>",
        "keys": "async keys(pattern: string): Promise<string[]>",
        "isAvailable": "isAvailable(): boolean"
      },
      "helper_functions": {
        "getCache": "async function getCache(key: string): Promise<string | null>",
        "setCache": "async function setCache(key: string, value: string, ttl: number): Promise<void>",
        "delCache": "async function delCache(pattern: string): Promise<void>",
        "initRedis": "async function initRedis(): Promise<void>",
        "checkRedisHealth": "async function checkRedisHealth(): Promise<HealthStatus>"
      },
      "ioredis_compatibility": {
        "version": "5.x",
        "deprecated_properties": [
          "retryDelayOnFailover - Does not exist in ioredis v5"
        ],
        "correct_api_usage": [
          "Use client.set(key, value, 'EX', ttl) instead of client.setex()",
          "Use client.keys(pattern) for pattern matching",
          "connectTimeout, maxRetriesPerRequest, enableOfflineQueue are valid"
        ]
      },
      "critical_notes": [
        "QWEN error: Used non-existent retryDelayOnFailover property",
        "Always verify ioredis API compatibility",
        "Provide both modern and legacy API compatibility",
        "Export helper functions for backward compatibility"
      ]
    },
    "active_session_model": {
      "file": "/backend/src/models/ActiveSession.ts",
      "purpose": "Session tracking model for concurrent login prevention",
      "properties": {
        "id": "string (UUID)",
        "userId": "string (UUID, foreign key to users)",
        "sessionToken": "string (JWT token, unique)",
        "deviceFingerprint": "string (optional)",
        "ipAddress": "INET (optional)",
        "userAgent": "string (optional)",
        "createdAt": "Date",
        "lastActivity": "Date",
        "expiresAt": "Date",
        "isActive": "boolean"
      },
      "instance_methods": {
        "isExpired": "(): boolean - Check if session expired",
        "invalidate": "(): Promise<void> - Mark session inactive",
        "updateActivity": "(): Promise<void> - Update lastActivity timestamp"
      },
      "sequelize_version": "v6",
      "critical_notes": [
        "QWEN error: Used .associate() method from Sequelize v5",
        "Sequelize v6: Associations defined in models/index.ts, NOT in model files",
        "DO NOT add static .associate() method to models",
        "Use Model.init() with sequelize instance"
      ],
      "correct_association_pattern": {
        "wrong": "ActiveSession.associate = (models) => { ... } // Sequelize v5 pattern",
        "correct": "// In models/index.ts: ActiveSession.belongsTo(User, { foreignKey: 'userId' })"
      }
    }
  },

  "ai_safety_protocols": {
    "union_type_access": {
      "wrong": "operator.username // unsafe",
      "correct": "typeof operator === 'object' && operator.username ? operator.username : operator"
    },
    "object_to_react_node": {
      "wrong": "{winner: 'rooster1', method: 'ko'} // directly in JSX",
      "correct": "JSON.stringify(result) or custom rendering component"
    },
    "missing_imports": {
      "verify_before_import": ["Subscription -> UserSubscription", "BetType -> not exists", "StreamQuality -> not exists"],
      "check_exports": "grep 'export.*{TypeName}' /frontend/src/types/index.ts"
    }
  },

  "validation_commands": {
    "type_check": "npx tsc --noEmit",
    "build_check": "npm run build",
    "import_verification": "grep -r 'import.*{TypeName}' frontend/src/",
    "export_verification": "grep 'export.*{TypeName}' frontend/src/types/index.ts"
  },

  "common_ai_errors": {
    "union_type_access": {
      "wrong": "operator.username // unsafe access",
      "correct": "typeof operator === 'object' && operator.username ? operator.username : operator"
    },
    "object_to_react_node": {
      "wrong": "{data} // directly in JSX",
      "correct": "JSON.stringify(data) or proper rendering component"
    },
    "missing_imports": {
      "verify_before_import": ["Subscription â†’ UserSubscription", "BetType â†’ not exists", "StreamQuality â†’ not exists"],
      "check_exports": "grep 'export.*{TypeName}' /frontend/src/types/index.ts"
    }
  },

  "ai_guidelines": {
    "before_modifications": [
      "Read existing interface definitions",
      "Verify all imports resolve",
      "Check union type usage patterns",
      "Confirm API response structure"
    ],
    "during_modifications": [
      "Never remove required properties",
      "Add type guards for union types",
      "Use index signatures for form compatibility",
      "Serialize objects before React rendering"
    ],
    "after_modifications": [
      "Run npx tsc --noEmit",
      "Test import/export resolution",
      "Verify no 'any' types introduced",
      "Check union type safety"
    ]
  },

  "machine_learning_integrations": {
    "anomaly_detection": {
      "description": "Implement ML-based anomaly detection for security and performance",
      "use_cases": [
        "Detecting unusual API access patterns that might indicate security threats",
        "Identifying performance anomalies before they affect users",
        "Recognizing fraudulent account behaviors"
      ]
    },
    "personalization_engine": {
      "description": "Create intelligent personalization based on user behavior and preferences",
      "implementation": "Analyze user interactions to serve personalized content, layouts, and features",
      "benefits": [
        "Higher user engagement",
        "Better conversion rates",
        "Improved user experience"
      ]
    }
  }
}