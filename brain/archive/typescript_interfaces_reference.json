{
  "metadata": {
    "purpose": "TypeScript interface reference for GalloBets platform",
    "version": "2.8",
    "last_updated": "2025-11-11",
    "changelog": "Added API mappings for admin bets endpoint and finance endpoints. No interface changes - endpoints use existing types.",
    "note": "Verified against backend database models and production deployment"
  },

  "core_interfaces": {
    "Fight": {
      "file": "/frontend/src/types/index.ts",
      "required_properties": ["id", "eventId", "number", "redCorner", "blueCorner", "weight", "status"],
      "optional_properties": ["description", "notes", "initialOdds", "bettingStartTime", "bettingEndTime", "result", "startTime", "endTime"],
      "status_enum": ["upcoming", "betting", "live", "completed", "cancelled"],
      "database_mapping": {
        "redCorner": "red_corner (database)",
        "blueCorner": "blue_corner (database)",
        "bettingStartTime": "betting_start_time (database)"
      },
      "critical_note": "VERIFIED against backend/src/models/Fight.ts - properties match database schema"
    },
    "Bet": {
      "file": "/backend/src/models/Bet.ts",
      "purpose": "Betting system with support for standard bets and PAGO/DOY matched proposals",
      "required_properties": ["id", "fightId", "userId", "side", "amount", "potentialWin", "status", "betType"],
      "optional_properties": ["matchedWith", "proposalStatus", "terms", "createdAt", "updatedAt"],
      "side_enum": ["red", "blue"],
      "status_enum": ["pending", "active", "won", "lost", "cancelled", "refunded"],
      "betType_enum": ["standard", "doy"],
      "proposalStatus_enum": ["pending", "accepted", "rejected", "expired"],
      "pago_doy_specific_fields": {
        "ðŸ”´_CRITICAL_2025_11_04": "PAGO/DOY matched bets now persist to database with transaction safety",
        "matchedWith": {
          "type": "string | null",
          "description": "ID of matched bet (bidirectional link between PAGO and DOY bets)",
          "usage": "PAGO bet.matchedWith = DOY bet.id, DOY bet.matchedWith = PAGO bet.id"
        },
        "proposalStatus": {
          "type": "'pending' | 'accepted' | 'rejected' | 'expired' | null",
          "description": "Status of PAGO/DOY proposal lifecycle",
          "workflow": "pending (created) â†’ accepted (matched) OR expired (timeout) OR rejected (declined)"
        },
        "terms": {
          "type": "object | null",
          "description": "PAGO/DOY proposal terms and metadata",
          "structure": {
            "ratio": "number (betting odds ratio)",
            "isOffer": "boolean (true for PAGO, false for DOY)",
            "pagoAmount": "number (PAGO bet amount)",
            "doyAmount": "number (DOY bet amount)",
            "proposedBy": "string (userId who created PAGO proposal)"
          }
        }
      },
      "database_persistence": {
        "transaction_pattern": "Matched bets created atomically with Sequelize transaction",
        "implementation": "backend/src/sockets/bettingSocket.ts:215-271",
        "pago_bet": {
          "betType": "'doy'",
          "proposalStatus": "'accepted'",
          "terms.isOffer": true,
          "matchedWith": "DOY bet ID (linked after DOY creation)"
        },
        "doy_bet": {
          "betType": "'doy'",
          "proposalStatus": "'accepted'",
          "terms.isOffer": false,
          "matchedWith": "PAGO bet ID (linked during creation)"
        },
        "rollback_behavior": "Transaction rollback on any error, both bets or none"
      },
      "common_errors": [
        "Missing matchedWith link in one direction",
        "Inconsistent proposalStatus between matched bets",
        "Transaction failure without rollback (fixed 2025-11-04)"
      ]
    },
    "SSEEventType": {
      "file": "/frontend/src/hooks/useSSE.ts",
      "type": "enum",
      "purpose": "Type-safe event names for Server-Sent Events subscription system",
      "values": {
        "SYSTEM_STATUS": "System-wide status updates",
        "FIGHT_STATUS_UPDATE": "Fight status transitions (upcoming â†’ betting â†’ live â†’ completed)",
        "NEW_BET": "New bet created and available for matching",
        "BET_MATCHED": "PAGO/DOY bet successfully matched between users",
        "BET_CANCELLED": "Bet cancelled by user or system",
        "BET_SETTLED": "Fight completed, bet result determined",
        "PAGO_PROPOSAL": "PAGO bet proposal created (3-minute timeout)",
        "DOY_PROPOSAL": "DOY acceptance of PAGO proposal",
        "BETTING_WINDOW_OPENED": "Fight entered betting status",
        "BETTING_WINDOW_CLOSED": "Fight exited betting status (no new bets)",
        "WALLET_UPDATE": "User wallet balance changed"
      },
      "ðŸ”´_CRITICAL_FIX_2025_11_04": {
        "issue": "BettingPanel used string literals instead of enum for subscribe()",
        "fix_location": "frontend/src/components/user/BettingPanel.tsx:56-65",
        "wrong_pattern": "subscribe('NEW_BET', callback) // String literal - BROKEN",
        "correct_pattern": "subscribe(SSEEventType.NEW_BET, callback) // Enum - CORRECT",
        "validation": "TypeScript compilation ZERO errors after fix"
      },
      "usage_pattern": {
        "import": "import { useFightSSE, SSEEventType } from '../../hooks/useSSE'",
        "subscription": "const unsubscribe = subscribe(SSEEventType.NEW_BET, (event) => { handleNewBet(event); })",
        "cleanup": "useEffect(() => { const cleanup = subscribe(...); return () => cleanup(); }, [deps])",
        "type_safety": "TypeScript enforces enum usage, prevents typos in event names"
      },
      "component_examples": {
        "BettingPanel": {
          "file": "frontend/src/components/user/BettingPanel.tsx",
          "subscriptions": [
            "SSEEventType.NEW_BET - Refresh available bets list",
            "SSEEventType.BET_MATCHED - Trigger onBetPlaced callback"
          ],
          "line_references": "Lines 56, 65 (fixed 2025-11-04)"
        }
      }
    },
    "User": {
      "file": "/frontend/src/types/index.ts",
      "required_properties": ["id", "username", "email", "role", "isActive", "approved", "createdAt", "updatedAt"],
      "optional_properties": ["profileInfo", "lastLogin", "subscription", "wallet", "events"],
      "role_enum": ["admin", "operator", "venue", "user", "gallera"],
      "approval_system": {
        "approved_field": "boolean - NEW FIELD 2025-10-29",
        "default_value": "false for public registrations, true for admin-created users",
        "approval_logic": "Users with role='venue'|'gallera' and approved=false are blocked by middleware until admin approves",
        "middleware_check": "authenticate middleware checks approved status before allowing requests"
      },
      "profileInfo_structure": {
        "basic_fields": ["fullName", "phoneNumber", "address", "identificationNumber", "verificationLevel"],
        "image_fields": ["images?: string[] - ADDED 2025-10-31 - Max 2 for venues, max 3 for galleras"],
        "venue_fields": ["businessName", "venueName", "venueLocation", "venueDescription", "venueEmail", "venueWebsite"],
        "gallera_fields": ["galleraName", "galleraLocation", "galleraDescription", "galleraEmail", "galleraWebsite", "galleraSpecialties", "galleraActiveRoosters"],
        "extended_fields": ["location", "description", "establishedDate", "certified", "rating", "premiumLevel", "specialties", "imageUrl"]
      },
      "backend_sync": {
        "ðŸ”´_CRITICAL_2025_10_30": "CONSOLIDATED ARCHITECTURE - NO SYNC NEEDED",
        "architecture_note": "venues and galleras tables ELIMINATED. All data stored ONLY in User.profileInfo JSONB field",
        "profile_data_location": "User.profileInfo (single source of truth)",
        "endpoint": "/users/profile (PUT) - updates User.profileInfo directly, no sync to other tables needed"
      }
    },
    "UserSubscription": {
      "file": "/frontend/src/types/index.ts",
      "required_properties": ["id", "plan", "status", "features"],
      "optional_properties": ["expiresAt", "manual_expires_at"],
      "status_enum": ["active", "cancelled", "expired", "pending"],
      "plan_types": ["free", "24-hour", "monthly"],
      "pricing": {
        "free": "$0 (default on expiration/cancellation)",
        "24-hour": "$5 (1 day access)",
        "monthly": "$10 (30 days access)"
      },
      "expiration_behavior": {
        "automatic_downgrade": "When expiresAt < current_timestamp, subscription automatically changes to 'free' type",
        "frontend_access_control": "Frontend components automatically restrict access to premium content when subscription expires",
        "middleware_validation": "authenticate middleware checks expiresAt on each request and enforces access restrictions",
        "immediate_effect": "Access restrictions take effect immediately when subscription expires without need for user logout/login"
      },
      "common_errors": [
        "Using 'type' instead of 'plan' property",
        "Missing 'id' property in form data",
        "Forgetting index signature for form compatibility"
      ]
    },
    "UserSubscriptionWithExpiry": {
      "file": "/frontend/src/types/index.ts",
      "extends": "UserSubscription",
      "additional_properties_for_frontend": ["expiresAt", "manual_expires_at", "current_status"],
      "computed_property": {
        "current_status": "Calculated property that combines status and expiresAt to determine if user has active access",
        "calculation": "status === 'active' && (expiresAt ? new Date(expiresAt) > new Date() : true) ? 'active_access' : 'limited_access'"
      },
      "frontend_usage": {
        "component": "/frontend/src/components/user/SubscriptionGuard.tsx",
        "purpose": "Component that hides/shows content based on subscription status",
        "access_control": "Blocks access to premium content when subscription is expired/inactive"
      }
    },
    
    "MembershipChangeRequest": {
      "file": "/backend/src/models/MembershipChangeRequest.ts",
      "required_properties": ["id", "userId", "requestedMembershipType", "status", "createdAt"],
      "optional_properties": ["requestNotes", "paymentProofUrl", "completedAt", "completedBy", "rejectionReason"],
      "status_enum": ["pending", "completed", "rejected"],
      "membership_type_enum": ["24-hour", "monthly"],
      "business_rules": [
        "User must have registered phone number to create request",
        "Only one pending request allowed per user at a time",
        "Cannot request if user already has active subscription (must wait for expiration)",
        "Cannot request 'free' tier (automatically assigned on expiration/cancellation)",
        "Admin/operator can complete or reject requests",
        "Payment proof URL is optional but recommended"
      ],
      "frontend_integration": {
        "user_component": "/frontend/src/components/user/MembershipSection.tsx",
        "admin_component": "/frontend/src/components/admin/SubscriptionTabs.tsx",
        "api_service": "/frontend/src/services/api.ts (membershipRequestsAPI)"
      },
      "api_endpoints": {
        "create": "POST /api/membership-requests",
        "my_requests": "GET /api/membership-requests/my-requests",
        "pending": "GET /api/membership-requests/pending (admin/operator only)",
        "complete": "PATCH /api/membership-requests/:id/complete (admin/operator only)",
        "reject": "PATCH /api/membership-requests/:id/reject (admin/operator only)"
      },
      "validation_rules": {
        "requestedMembershipType": "Required, must be '24-hour' or 'monthly'",
        "requestNotes": "Optional, max 1000 characters",
        "paymentProofUrl": "Optional, max 500 characters, must be valid URL format",
        "rejectionReason": "Required when rejecting, max 500 characters"
      },
      "common_errors": [
        "Using 'type' instead of 'requestedMembershipType' field",
        "Attempting to request 'free' tier (not allowed)",
        "Creating duplicate pending request (one per user limit)",
        "Missing phone number in user profile"
      ]
    },
    "EventConnection": {
      "file": "/backend/src/models/EventConnection.ts",
      "purpose": "Track user connections to events for real-time viewer count and historical analytics",
      "required_properties": ["id", "event_id", "user_id", "session_id", "connected_at"],
      "optional_properties": ["disconnected_at", "duration_seconds", "ip_address", "user_agent"],
      "database_table": "event_connections",
      "indexes": [
        "idx_event_connections_event_disconnected (event_id, disconnected_at) - For fast viewer queries"
      ],
      "field_descriptions": {
        "id": "number - Primary key, auto-increment",
        "event_id": "number - Foreign key to events table",
        "user_id": "number - Foreign key to users table",
        "session_id": "string - Unique session identifier",
        "connected_at": "Date - Timestamp when user connected",
        "disconnected_at": "Date | null - Timestamp when user disconnected (null if still connected)",
        "duration_seconds": "number | null - Total connection duration in seconds",
        "ip_address": "string | null - User IP address for security auditing",
        "user_agent": "string | null - Browser/device information"
      },
      "usage_scenarios": [
        "Real-time viewer count: Count where disconnected_at IS NULL",
        "Historical analytics: Aggregate data with user joins",
        "Security auditing: Track unusual connection patterns",
        "Performance metrics: Average watch time per event"
      ],
      "api_endpoints": {
        "get_viewers": "GET /api/events/:id/viewers - Real-time viewer count",
        "get_analytics": "GET /api/events/:id/analytics - Historical connection data with user details"
      },
      "automatic_tracking": {
        "connection": "Tracked via streamingSocket.trackConnection() in backend/src/sockets/streamingSocket.ts:8",
        "disconnection": "Tracked via streamingSocket.trackDisconnection() in backend/src/sockets/streamingSocket.ts:22",
        "duration_calculation": "Auto-calculated on disconnection: (disconnected_at - connected_at) / 1000"
      },
      "business_value": [
        "Monitor event popularity in real-time",
        "Identify most popular events/times",
        "Detect account sharing (multiple concurrent connections)",
        "Calculate average engagement per event",
        "Security: Track suspicious connection patterns"
      ]
    },
    "EventData": {
      "file": "/frontend/src/types/index.ts",
      "union_types": {
        "operator": "string | { username: string }",
        "status": "upcoming | live | completed | cancelled | betting | in-progress | scheduled"
      },
      "required_properties": ["id", "name", "status", "venue", "createdAt", "updatedAt", "venueId"],
      "recently_added": ["streamKey", "currentViewers", "activeBets", "completedFights", "totalFights", "totalPrizePool", "streamStatus", "fights"],
      "venue_structure": {
        "ðŸ”´_FASE_5_2025_11_05": "venue object now includes optional profileInfo field for consolidated architecture",
        "required_fields": ["id", "name"],
        "optional_fields": ["location", "profileInfo"],
        "profileInfo_fields": ["venueName", "venueLocation", "venueDescription", "venueEmail", "venueWebsite", "images"],
        "access_pattern": "event.venue?.profileInfo?.venueName || event.venue?.name || 'Venue TBD'",
        "backend_response": "Venue data comes from User.profileInfo (single source of truth post-FASE 5 consolidation)",
        "note": "profileInfo field added 2025-11-05 to support FASE 5 consolidated architecture where venues exist as User records with role='venue'"
      }
    },
    "Venue": {
      "file": "/frontend/src/types/index.ts",
      "deprecated": "ðŸ”´ 2025-10-30 CRITICAL: venues table ELIMINATED. Venue data now in User.profileInfo",
      "note_2025_10_30": "GET /venues returns User objects (role='venue'), NOT Venue objects. Frontend MUST access profileInfo for venue details.",
      "api_endpoint_note": "ðŸ”´ CHANGED 2025-10-30: GET /venues now returns User.findAndCountAll({role:'venue'}) with data in profileInfo (venueName, venueLocation, venueDescription, etc). NO venues table exists.",
      "response_structure": {
        "users": [
          {
            "id": "UUID (user.id)",
            "username": "string",
            "email": "string",
            "role": "'venue'",
            "approved": "boolean",
            "profileInfo": {
              "venueName": "string (was venue.name)",
              "venueLocation": "string (was venue.location)",
              "venueDescription": "string (was venue.description)",
              "venueEmail": "string",
              "venueWebsite": "string",
              "businessName": "string"
            },
            "images": "string[] | null"
          }
        ]
      },
      "frontend_migration": "Replace venue.name â†’ user.profileInfo.venueName, venue.location â†’ user.profileInfo.venueLocation, etc"
    },
    "Article": {
      "file": "/frontend/src/types/article.ts",
      "required_properties": ["id", "title", "slug", "content", "status", "created_at"],
      "optional_properties": ["excerpt", "featured_image", "published_at", "author"],
      "FASE_5_NOTE": "venue_id REMOVED (2025-11-07) per PRD:205 - Articles use ONLY author_id",
      "backend_auto_generated": ["slug"],
      "slug_generation": {
        "source": "Generated from title field",
        "format": "URL-friendly (lowercase, hyphens, no special chars)",
        "uniqueness": "Enforced by backend with automatic numbering (e.g., title-1, title-2)",
        "frontend_note": "NEVER send slug in POST/PUT requests - backend auto-generates"
      },
      "deprecated_fields": ["summary", "featured_image_url", "venue", "venue_id"],
      "api_mapping": {
        "POST /articles": {
          "required": ["title", "content", "excerpt"],
          "optional": ["featured_image"],
          "REMOVED_2025_11_07": "venue_id field no longer accepted",
          "CRITICAL_WARNING": "Frontend MUST send 'excerpt' NOT 'summary', and 'featured_image' NOT 'featured_image_url'"
        }
      },
      "common_errors": [
        "Using 'summary' instead of 'excerpt' field in API calls",
        "Using 'featured_image_url' instead of 'featured_image' in API calls",
        "Missing required fields: title (min 5 chars), content (min 10 chars), excerpt (min 10, max 500 chars)"
      ]
    },
    "Gallera": {
      "file": "/frontend/src/types/index.ts",
      "deprecated": "ðŸ”´ 2025-10-30 CRITICAL: galleras table ELIMINATED. Gallera data now in User.profileInfo",
      "note_2025_10_30": "GET /galleras returns User objects (role='gallera'), NOT Gallera objects. Frontend MUST access profileInfo for gallera details.",
      "api_endpoint_note": "ðŸ”´ CHANGED 2025-10-30: GET /galleras now returns User.findAndCountAll({role:'gallera'}) with data in profileInfo (galleraName, galleraLocation, galleraDescription, etc). NO galleras table exists.",
      "response_structure": {
        "users": [
          {
            "id": "UUID (user.id)",
            "username": "string",
            "email": "string",
            "role": "'gallera'",
            "approved": "boolean",
            "profileInfo": {
              "galleraName": "string (was gallera.name)",
              "galleraLocation": "string (was gallera.location)",
              "galleraDescription": "string (was gallera.description)",
              "galleraEmail": "string",
              "galleraWebsite": "string",
              "galleraSpecialties": "string | object (was specialties)",
              "galleraActiveRoosters": "number (was activeRoosters)",
              "businessName": "string"
            },
            "images": "string[] | null"
          }
        ]
      },
      "frontend_migration": "Replace gallera.name â†’ user.profileInfo.galleraName, gallera.location â†’ user.profileInfo.galleraLocation, etc",
      "common_errors": [
        "âŒ NEVER access venue or gallera table directly - tables don't exist",
        "âŒ NEVER destructure response.data.venues/galleras - it returns response.data.users",
        "âœ… Always access profileInfo fields: user.profileInfo.galleraName, user.profileInfo.venueName, etc"
      ]
    },
    
    "UserProfileWithSubscription": {
      "file": "/frontend/src/types/index.ts",
      "integration": "Primary interface for user profile with subscription integration",
      "composition": {
        "extends": "User interface",
        "additional_field": "subscription: UserSubscription object",
        "usage_location": "GET /api/users/profile response includes both user data and current subscription status"
      },
      "frontend_utility": {
        "access_pattern": "response.data.user for user info and response.data.subscription for subscription status",
        "subscription_check": "Frontend components use both user.profileInfo.verificationLevel and subscription.status to determine access permissions",
        "premium_content_logic": "Premium content access requires BOTH verified account AND active subscription"
      },
      "response_structure": {
        "success": true,
        "data": {
          "user": "User object with profileInfo",
          "subscription": "UserSubscription object with status and expiration"
        }
      },
      "expiration_handling": {
        "automatic_update": "Frontend components automatically update access controls when subscription expires",
        "visual_feedback": "Premium indicators automatically hide when subscription is no longer active",
        "navigation_adjustment": "Menu items adjust automatically based on current subscription status"
      }
    }
  },

  "role_based_restrictions": {
    "betting_access_control": {
      "interface": "User.role enum",
      "allowed_roles_for_betting": ["user", "gallera"],
      "blocked_roles_for_betting": ["admin", "operator", "venue"],
      "implementation_location": "backend/src/routes/bets.ts (middleware)",
      "frontend_impact": {
        "navigation": "Venue users won't see Betting/My Bets links in sidebar (frontend/src/components/user/Navigation.tsx)",
        "components": "Betting panel and related components only accessible to allowed roles",
        "ux_pattern": "Conditional rendering based on user role"
      },
      "backend_impact": {
        "api_restriction": "403 Forbidden response for blocked roles on /api/bets endpoints",
        "websocket_restriction": "PAGO/DOY WebSocket events reject unauthorized roles",
        "error_message": "Betting access denied - Your role cannot place bets"
      },
      "business_reason": "Venue users host events but do NOT participate in betting to separate business roles",
      "added_date": "2025-11-07"
    }
  },

  "component_interfaces": {
    "image_gallery_upload": {
      "file": "/frontend/src/components/shared/ImageGalleryUpload.tsx",
      "component_name": "ImageGalleryUpload",
      "purpose": "Reusable multi-image upload component with gallery grid display",
      "props": {
        "images": "string[] (required) - Array of image URLs",
        "onImagesChange": "(images: string[]) => void (required) - Callback when images array changes",
        "maxImages": "number (optional, default: 10) - Maximum number of images allowed",
        "label": "string (optional, default: 'GalerÃ­a de ImÃ¡genes') - Component label"
      },
      "features": [
        "Multiple image upload support",
        "Grid display of uploaded images (2-4 columns responsive)",
        "Individual image deletion with hover action",
        "Loading state during upload",
        "File type validation (image/* only)",
        "File size validation (max 5MB per image)",
        "Error handling per image with user feedback",
        "Image counter showing used/max images"
      ],
      "usage_examples": [
        "UnifiedEntityForm.tsx: Manages venue/gallera images gallery (REPLACES VenueEntityForm + GalleraEntityForm) - UPDATED 2025-11-04",
        "CreateUserModal.tsx: Role-based image upload (venue maxImages=2, gallera maxImages=3) - ADDED 2025-10-31",
        "EditVenueGalleraModal.tsx: Entity Info tab image management - ADDED 2025-10-31",
        "Supports ARRAY(string) database fields",
        "ðŸ”´ DEPRECATED: VenueEntityForm.tsx.deprecated, GalleraEntityForm.tsx.deprecated (replaced by UnifiedEntityForm 2025-11-04)"
      ],
      "validation": {
        "file_type": "file.type.startsWith('image/')",
        "file_size": "max 5MB (5 * 1024 * 1024)",
        "max_images": "Configurable, default 10"
      },
      "api_integration": "Uses uploadsAPI.uploadImage(file) for server upload",
      "styling": "TailwindCSS with Lucide React icons (Camera, X, Loader)"
    },
    "UnifiedEntityForm": {
      "file": "/frontend/src/components/forms/UnifiedEntityForm.tsx",
      "purpose": "ðŸ”´ FASE 5: Unified form component for venue/gallera profile management, replaces VenueEntityForm + GalleraEntityForm (75% code reduction)",
      "interface": "UnifiedEntityFormProps",
      "required_properties": {
        "entityType": "'venue' | 'gallera' - Determines which fields to render",
        "userId": "string - ID of user whose profileInfo will be updated",
        "onSuccess": "(updatedUser: User) => void - Callback after successful save",
        "onCancel": "() => void - Callback when user cancels"
      },
      "optional_properties": {
        "initialData": "Record<string, any> - Pre-populate form with user.profileInfo data"
      },
      "architecture": {
        "consolidation_pattern": "Single component with conditional field rendering based on entityType",
        "api_call": "usersAPI.updateProfileInfo(userId, profileInfoUpdate)",
        "replaces": "Deprecated venuesAPI.update() and gallerasAPI.update() calls",
        "code_metrics": {
          "old_approach": "VenueEntityForm (248 lines) + GalleraEntityForm (363 lines) = 611 lines",
          "new_approach": "UnifiedEntityForm (321 lines) = 75% code reduction",
          "shared_logic": "Business name, location, description, email, website, images (common fields)",
          "entity_specific": "galleraSpecialties, galleraActiveRoosters (only for gallera)"
        }
      },
      "field_mapping": {
        "venue": ["venueName (businessName)", "venueLocation", "venueDescription", "venueEmail", "venueWebsite", "images (max 2)"],
        "gallera": ["galleraName (businessName)", "galleraLocation", "galleraDescription", "galleraEmail", "galleraWebsite", "galleraSpecialties", "galleraActiveRoosters", "images (max 3)"]
      },
      "usage_example": "<UnifiedEntityForm entityType=\"venue\" userId={user.id} initialData={user.profileInfo} onSuccess={handleSave} onCancel={handleCancel} />",
      "integration": {
        "parent_component": "Profile.tsx (lines 261-267)",
        "usage_context": "When venue/gallera user edits business information",
        "data_flow": "user.profileInfo â†’ form fields â†’ usersAPI.updateProfileInfo() â†’ refreshUser()"
      },
      "migration_guide": {
        "old_pattern": {
          "component": "<VenueEntityForm venue={venueData} userId={user.id} onSave={handleSave} onCancel={handleCancel} />",
          "data_source": "venueData from GET /venues API (now deprecated)",
          "api_call": "venuesAPI.update(venueId, data)"
        },
        "new_pattern": {
          "component": "<UnifiedEntityForm entityType=\"venue\" userId={user.id} initialData={user.profileInfo} onSuccess={handleSave} onCancel={handleCancel} />",
          "data_source": "user.profileInfo (direct access, no separate API call)",
          "api_call": "usersAPI.updateProfileInfo(userId, data)"
        }
      },
      "added_date": "2025-11-04 (FASE 5 consolidation)"
    }
  },

  "upload_interfaces": {
    "upload_response": {
      "file": "/frontend/src/services/api.ts",
      "interface": "ApiResponse<UploadData>",
      "properties": {
        "success": "boolean",
        "data": {
          "filename": "string",
          "originalName": "string",
          "url": "string",
          "size": "number",
          "mimetype": "string"
        }
      },
      "usage_example": "const response = await uploadsAPI.uploadImage(file); const imageUrl = response.data.url;",
      "implementation_notes": [
        "File upload uses FormData with multer backend",
        "Authentication required via Bearer token",
        "Images stored in backend/uploads/images/ directory",
        "Served via /uploads/images/{filename} static route"
      ]
    },
    "frontend_upload_integration": {
      "component": "ArticleEditor.tsx",
      "handler": "handleImageChange",
      "workflow": [
        "User selects file via input[type=file]",
        "handleImageChange calls uploadsAPI.uploadImage(file)",
        "Response provides URL for immediate preview",
        "URL stored in form data as featured_image field",
        "Article save includes image URL in database"
      ],
      "error_handling": "Try-catch with user-friendly alerts",
      "loading_state": "uploading boolean with disabled input"
    }
  },

  "api_response_patterns": {
    "standard_response": {
      "structure": "ApiResponse<T>",
      "properties": ["success", "data", "error?", "code?", "message?"],
      "data_access": "response.data.{entityType}",
      "examples": {
        "venues": "response.data.venues",
        "galleras": "response.data.galleras",
        "users": "response.data.users"
      }
    },
    "pagination_response": {
      "additional_properties": ["total", "totalPages"],
      "access_pattern": "response.data.total"
    }
  },

  "common_ai_errors": {
    "union_type_access": {
      "wrong": "operator.username // unsafe",
      "correct": "typeof operator === 'object' && operator.username ? operator.username : operator"
    },
    "object_to_reactnode": {
      "wrong": "{winner: 'rooster1', method: 'ko'} // directly in JSX",
      "correct": "JSON.stringify(result) or custom rendering component"
    },
    "missing_imports": {
      "verify_before_import": ["Subscription -> UserSubscription", "BetType -> not exists", "StreamQuality -> not exists"],
      "check_exports": "grep 'export.*{TypeName}' /frontend/src/types/index.ts"
    }
  },

  "validation_commands": {
    "type_check": "npx tsc --noEmit",
    "build_check": "npm run build",
    "import_verification": "grep -r 'import.*{TypeName}' frontend/src/",
    "export_verification": "grep 'export.*{TypeName}' frontend/src/types/index.ts"
  },

  "ai_safety_protocol": {
    "before_modifications": [
      "Read existing interface definitions",
      "Verify all imports resolve",
      "Check union type usage patterns",
      "Confirm API response structure"
    ],
    "during_modifications": [
      "Never remove required properties",
      "Add type guards for union types",
      "Use index signatures for form compatibility",
      "Serialize objects before React rendering"
    ],
    "after_modifications": [
      "Run npx tsc --noEmit",
      "Test import/export resolution",
      "Verify no 'any' types introduced",
      "Check union type safety"
    ]
  },

  "backend_type_extensions": {
    "express_request_extensions": {
      "file": "/backend/src/types/express.d.ts",
      "purpose": "Extend Express Request interface for session management",
      "properties_added": {
        "user": {
          "type": "User (from models)",
          "optional": true,
          "added_by": "Authentication middleware",
          "usage": "Access authenticated user in request handlers"
        },
        "sessionToken": {
          "type": "string",
          "optional": true,
          "added_by": "enhancedAuthenticate middleware",
          "usage": "JWT token for session invalidation on logout"
        }
      },
      "implementation_pattern": {
        "declaration": "declare global { namespace Express { interface Request { user?: User; sessionToken?: string; } } }",
        "export": "export {}; // Required for module augmentation",
        "usage_example": "req.user.id // Available after authentication"
      },
      "critical_notes": [
        "MUST use 'declare global' for Express augmentation",
        "MUST export {} for TypeScript module system",
        "MUST import User type from models",
        "Properties are optional (added by middleware)"
      ],
      "related_middleware": [
        "/backend/src/middleware/enhancedAuth.ts - Sets req.user and req.sessionToken",
        "/backend/src/middleware/auth.ts - Legacy auth (sets req.user only)"
      ]
    },
    "redis_client_interface": {
      "file": "/backend/src/config/redis.ts",
      "class": "SafeRedisClient",
      "purpose": "Type-safe Redis client wrapper with fallback cache",
      "public_methods": {
        "get": "async get(key: string): Promise<string | null>",
        "set": "async set(key: string, value: string, ttl: number = 300): Promise<void>",
        "setex": "async setex(key: string, ttl: number, value: string): Promise<void> // Legacy alias",
        "del": "async del(pattern: string): Promise<void>",
        "keys": "async keys(pattern: string): Promise<string[]>",
        "isAvailable": "isAvailable(): boolean"
      },
      "helper_functions": {
        "getCache": "async function getCache(key: string): Promise<string | null>",
        "setCache": "async function setCache(key: string, value: string, ttl: number): Promise<void>",
        "delCache": "async function delCache(pattern: string): Promise<void>",
        "initRedis": "async function initRedis(): Promise<void>",
        "checkRedisHealth": "async function checkRedisHealth(): Promise<HealthStatus>"
      },
      "ioredis_compatibility": {
        "version": "5.x",
        "deprecated_properties": [
          "retryDelayOnFailover - Does not exist in ioredis v5"
        ],
        "correct_api_usage": [
          "Use client.set(key, value, 'EX', ttl) instead of client.setex()",
          "Use client.keys(pattern) for pattern matching",
          "connectTimeout, maxRetriesPerRequest, enableOfflineQueue are valid"
        ]
      },
      "critical_notes": [
        "QWEN error: Used non-existent retryDelayOnFailover property",
        "Always verify ioredis API compatibility",
        "Provide both modern and legacy API compatibility",
        "Export helper functions for backward compatibility"
      ]
    },
    "active_session_model": {
      "file": "/backend/src/models/ActiveSession.ts",
      "purpose": "Session tracking model for concurrent login prevention",
      "properties": {
        "id": "string (UUID)",
        "userId": "string (UUID, foreign key to users)",
        "sessionToken": "string (JWT token, unique)",
        "deviceFingerprint": "string (optional)",
        "ipAddress": "INET (optional)",
        "userAgent": "string (optional)",
        "createdAt": "Date",
        "lastActivity": "Date",
        "expiresAt": "Date",
        "isActive": "boolean"
      },
      "instance_methods": {
        "isExpired": "(): boolean - Check if session expired",
        "invalidate": "(): Promise<void> - Mark session inactive",
        "updateActivity": "(): Promise<void> - Update lastActivity timestamp"
      },
      "sequelize_version": "v6",
      "critical_notes": [
        "QWEN error: Used .associate() method from Sequelize v5",
        "Sequelize v6: Associations defined in models/index.ts, NOT in model files",
        "DO NOT add static .associate() method to models",
        "Use Model.init() with sequelize instance"
      ],
      "correct_association_pattern": {
        "wrong": "ActiveSession.associate = (models) => { ... } // Sequelize v5 pattern",
        "correct": "// In models/index.ts: ActiveSession.belongsTo(User, { foreignKey: 'userId' })"
      }
    }
  },
  "component_documentation": {
    "UserModal": {
      "file": "/frontend/src/components/admin/UserModal.tsx",
      "purpose": "Unified component for creating and editing users with role-based fields",
      "props": {
        "mode": "'create' | 'edit' (required)",
        "role": "'operator' | 'venue' | 'gallera' | 'user' (required)",
        "user": "User (optional, required for edit mode)",
        "onClose": "() => void (required)",
        "onSuccess": "(user?: User) => void (required)"
      },
      "features": [
        "Profile and Subscription tabs",
        "Role-based conditional fields",
        "Image upload integration",
        "Approval status management",
        "isActive checkbox in both modes",
        "Subscription management post-creation"
      ]
    }
  },
  "hooks_documentation": {
    "useUserForm": {
      "file": "/frontend/src/hooks/useUserForm.ts",
      "purpose": "Centralize form state management for create/edit modes",
      "parameters": ["mode: 'create' | 'edit'", "role: 'operator' | 'venue' | 'gallera' | 'user'", "initialUser?: User"],
      "returns": ["formData", "handleChange", "handleArrayChange", "handleImagesChange", "handleSubmit", "error"],
      "handleChange_enhancement": "Supports nested field names with dot notation (e.g., 'profileInfo.fullName')"
    },
    "useUserSubscription": {
      "file": "/frontend/src/hooks/useUserSubscription.ts",
      "purpose": "Centralize subscription management logic",
      "parameters": ["userId: string", "initialSubscription?: UserSubscription"],
      "returns": ["subscription", "isUpdating", "updateSubscription"]
    }
  }
}