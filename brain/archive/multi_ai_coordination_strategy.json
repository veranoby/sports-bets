{
  "üìã_TABLE_OF_CONTENTS": {
    "ai_roles_and_preferences": "Lines 5-35 (READ FIRST - Core Configuration)",
    "critical_rules": "Lines 36-280 (Non-negotiable Protocols - INCLUDES DIRECTOR_PLANNING_PROTOCOL + AUDIT_METHODOLOGY_PROTOCOL)",
    "role_responsibilities": "Lines 282-350",
    "execution_workflows": "Lines 351-440",
    "validation_gates": "Lines 441-500",
    "failure_recovery": "Lines 501-590",
    "recommended_practices": "Lines 591-780",
    "business_clarifications": "Lines 781-880"
  },

  "metadata": {
    "version": "5.2",
    "updated": "2025-11-11",
    "purpose": "Role-based AI orchestration framework - decoupled, resilient, and future-proof.",
    "note": "This file is READ-FIRST by all AIs. Core logic is based on ROLES, not specific models. Model selection is a configuration preference.",
    "prompt_files_location": "PROJECT ROOT (director-prompt.json, executor-prompt.json) - Role-based prompts for easier AI access.",
    "changelog_v5.2": "Added AUDIT_AND_ANALYSIS_METHODOLOGY_PROTOCOL (lines 146-280) - Prevents unidirectional search, tool validation failures, and 'absence of finding = absence of existence' errors. Incident lesson: 2025-11-11 backend audit missed existing endpoints.",
    "changelog_v5.1": "Added DIRECTOR_PLANNING_PROTOCOL (lines 77-99) - Director MUST read this file BEFORE creating executor plans to incorporate all critical error prevention protocols"
  },

  "ai_roles_and_preferences": {
    "description": "Defines the abstract roles in the system and the preferred models for each role. This allows for dynamic model swapping without changing core logic.",
    "director": {
      "description": "Responsible for architecture, planning, validation, high-level oversight, and declaring execution mode.",
      "preferred_models": [
        "claude-sonnet-4-5",
        "claude-opus-4",
        "glm-4-6"
      ],
      "forbidden_models": [
        "haiku-4-5"
      ]
    },
    "executor": {
      "description": "Responsible for specific, bounded implementation tasks (backend API, frontend components). Operates under a plan from the director.",
      "preferred_models": [
        "qwen3-coder-plus-2025-09-23",
        "gemini-2.0-flash-thinking-exp"
      ],
      "forbidden_models": []
    }
  },

  "execution_mode": {
    "description": "Global setting that dictates the level of validation and friction in the workflow. MUST be declared at session start by the AI in the 'director' role.",
    "standard": {
      "description": "Default mode. Maximum safety and validation. All protocols, simulations, and gates are strictly enforced. Recommended for complex tasks, database work, or high-risk changes.",
      "implications": [
        "simulate_y_confirmar_protocol is MANDATORY for all code changes.",
        "All validation_gates (TypeScript, build, etc.) are MANDATORY.",
        "Strict adherence to scope and file lists."
      ]
    },
    "trusted": {
      "description": "Expert mode for low-risk, high-speed iterations. Allows skipping certain non-critical validation steps for simple, well-understood tasks. Requires explicit user confirmation to activate.",
      "implications": [
        "simulate_y_confirmar_protocol can be SKIPPED for tasks with complexity='LOW'.",
        "npm run build gate can be SKIPPED for UI-only changes (e.g., CSS, text) after TypeScript validation.",
        "AI is allowed more autonomy, but must still report scope violations.",
        "User activation required: 'Activating TRUSTED mode for this session. Confirm Y/N?'"
      ]
    }
  },

  "üî¥_MCP_ACTIVATION_FOR_ALL_AIS": {
    "severity": "CRITICAL",
    "when_to_activate": {
      "database_sql_work": {"mcps": ["--c7", "--context7"], "why": "PostgreSQL type system expertise"},
      "multi_step_backend": {"mcps": ["--seq", "--sequential"], "why": "Dependency planning"},
      "react_typescript": {"mcps": ["--c7", "--context7"], "why": "React + TypeScript patterns"},
      "responsive_design": {"mcps": ["--play", "--playwright"], "why": "UI validation"},
      "code_analysis": {"mcps": ["--seq", "--sequential"], "why": "Systematic decomposition"}
    },
    "incident_lesson": "2025-10-30: PostgreSQL error occurred without Context7. LESSON: MCPs aren't optional - they're mandatory for quality."
  },

  "üî¥_DIRECTOR_PLANNING_PROTOCOL": {
    "severity": "CRITICAL",
    "principle": "Director AI MUST read this coordination strategy file BEFORE creating ANY plan for executor work",
    "rule": "When tasked with creating executor plans (JSON prompts, task specifications, work plans): Read brain/multi_ai_coordination_strategy.json FIRST, THEN create plan incorporating all critical protocols",
    "rationale": "Plans created without reading this file miss critical error prevention protocols, waste tokens on corrections, and risk executor failures",
    "mandatory_sequence_for_plan_creation": [
      "Step 1: User requests plan creation for executor work",
      "Step 2: IMMEDIATELY read brain/multi_ai_coordination_strategy.json (DO NOT skip this)",
      "Step 3: Identify which critical protocols apply (task_disambiguation, reporting_location, session_context_loss, evidence_based_validation)",
      "Step 4: Create plan incorporating ALL applicable protocols with explicit references to strategy file",
      "Step 5: Verify plan includes: session start declaration, task echo back, exact reporting location, checkpoint protocol, evidence requirements",
      "Step 6: Present plan to user"
    ],
    "critical_elements_every_executor_plan_must_include": {
      "session_start_protocol": "Mandatory declaration: Model + Role + Mode + Task echo back with user confirmation",
      "reporting_location": "EXACT file path where executor must report (not vague 'update brain/' instructions)",
      "session_management": "Hard time limits + checkpoint frequency + context refresh triggers + handoff note format",
      "evidence_requirements": "Specific command outputs and metrics executor must provide as proof of completion",
      "reference_to_protocols": "Explicit line number citations from this coordination strategy file"
    },
    "enforcement": "If director creates plan without reading this file first: User should reject plan and instruct director to read coordination strategy, then recreate plan",
    "lesson_learned": "Creating plans from memory or assumptions leads to missing critical protocols that prevent executor errors. Always read source of truth first."
  },

  "üî¥_ROLE_AND_MODEL_AWARENESS_PROTOCOL": {
    "severity": "CRITICAL",
    "rule": "Every AI session MUST start by declaring its model, its assigned ROLE, and task appropriateness.",
    "role_model_validation": "The directing AI (or the user) MUST validate that the declared model is in the 'preferred_models' list for its assigned role and NOT in the 'forbidden_models' list.",
    "inappropriate_model_for_role": "If a model is assigned to a role for which it is forbidden (e.g., Haiku as director), the session must be STOPPED. The AI must refuse and recommend a valid model from the preferred list for that role.",
    "unknown_task_protocol": {
      "description": "Protocol for when an AI cannot classify a task into a known pattern.",
      "trigger": "AI classifies task as 'not in MCP table' or 'not covered by existing workflows'.",
      "action": "STOP and report: 'Task [description] does not match known patterns. Requires human definition of a new protocol or manual execution. Awaiting instructions.'",
      "enforcement": "AI MUST NOT attempt to execute an unknown task with a guessed protocol."
    },
    "director_start_protocol": [
      "Read ~/.claude/CLAUDE.md",
      "Read project CLAUDE.md",
      "Read brain/multi_ai_coordination_strategy.json",
      "Declare execution_mode",
      "Classify task",
      "Check MCP table",
      "Activate agents/MCPs",
      "Document activation",
      "Proceed"
    ],
    "enforcement": "If an AI is assigned a role it cannot fulfill, or fails to declare its role and model, the user must interrupt and restart the session."
  },

  "üî¥_BASIC_PROTOCOL_ALL_AIS": {
    "severity": "CRITICAL",
    "rule_1": "READ COMPLETELY - Don't assume context. If user says 'I deleted users except admin' ‚Üí that's a FACT.",
    "rule_2": "NO FILE CREATION - Reports go in chat text only. Updates go to brain/ only. NEVER create .md files.",
    "rule_3": "BRAIN = SOURCE OF TRUTH - Update brain/ after every major task. Never scatter docs across root.",
    "rule_4": "EFFICIENCY NOT SPEED - Plan before executing. Trust user's explicit statements. Don't re-verify what they already confirmed.",
    "rule_5": "REPORT IN TEXT - Analysis happens in chat message area, not separate files."
  },

  "debugging_methodology_protocol": {
    "when": "User reports error with stack trace, or previous fix attempts failed",
    "responsible_ai": "AI in the 'director' role (root-cause-analyst mode recommended)",
    "step_1_analyze_not_fix": "PAUSE - Do NOT modify code yet. Ask: 'What assumptions could cause this? What conditions must be true?'",
    "step_2_identify_root_causes": "Walk through AT LEAST 2 possible causes based on stack trace and common misuse patterns",
    "step_3_validate_hypothesis": "Propose fix with specific test steps to validate (e.g., 'Add console.log(context) before failing line')",
    "step_4_avoid_repeats": "Never repeat previous failed attempts. Ask clarifying questions if uncertain.",
    "enforcement": "Director AI checks root cause BEFORE proposing fix"
  },

  "üî¥_AUDIT_AND_ANALYSIS_METHODOLOGY_PROTOCOL": {
    "severity": "CRITICAL",
    "principle": "Comprehensive, bidirectional verification with tool validation. Absence of finding ‚â† absence of existence.",
    "applicability": "All audit tasks, analysis requests, discrepancy investigations, or 'confirm X is reflected in Y' type requests",

    "core_rules": {
      "rule_1_bidirectional_search": {
        "description": "For any 'A vs B' comparison, search BOTH directions",
        "examples": [
          "Backend audit: Check (1) brain ‚Üí backend: 'Is documented endpoint implemented?' AND (2) backend ‚Üí brain: 'Is implemented endpoint documented?'",
          "File analysis: Check (1) 'Does file X contain Y?' AND (2) 'What else is in file X that we haven't accounted for?'"
        ],
        "enforcement": "MANDATORY for all audit/analysis tasks. Both directions must be explicitly performed and reported."
      },

      "rule_2_tool_validation": {
        "description": "Verify tool outputs are valid before trusting results",
        "trigger_scenarios": [
          "Grep/search returns empty ‚Üí VERIFY with direct file Read",
          "Command shows '0 results' ‚Üí CONFIRM with alternative method",
          "Unexpected result from automation ‚Üí MANUALLY VERIFY sample"
        ],
        "protocol_when_tool_fails": [
          "Step 1: Acknowledge tool may have failed (syntax error, path issue, etc.)",
          "Step 2: Switch to direct method (Read file, manual inspection)",
          "Step 3: Document which tool failed and why in report",
          "Step 4: Use validated method for remaining work"
        ],
        "enforcement": "NEVER assume 'empty result = nothing exists' without validation"
      },

      "rule_3_systematic_coverage": {
        "description": "Enumerate search space completely before concluding",
        "checklist": [
          "List all files/endpoints/entities in scope",
          "Create explicit checklist of what to verify",
          "Check off items as verified (not assumed)",
          "Report both 'verified present' AND 'verified absent' findings"
        ],
        "anti_pattern": "Checking a few examples and extrapolating",
        "enforcement": "For audits: Provide counts (X files checked, Y endpoints verified, Z discrepancies found)"
      },

      "rule_4_direct_inspection": {
        "description": "When in doubt, read the source directly",
        "trigger": "Any of: (1) Tool returns unexpected result, (2) Critical finding needs confirmation, (3) Ambiguity in automated results",
        "method": "Use Read tool with specific offset/limit to manually inspect actual code/config/data",
        "enforcement": "Grep is for discovery, Read is for validation"
      },

      "rule_5_explicit_assumptions": {
        "description": "State and validate all assumptions before concluding",
        "process": [
          "List assumptions being made (e.g., 'Assuming all routes are in routes/ directory')",
          "Validate each assumption explicitly (e.g., 'Verified: grep shows no routes defined elsewhere')",
          "Document validated assumptions in report"
        ],
        "enforcement": "Report must include 'Assumptions Made' and 'Assumptions Validated' sections for complex audits"
      }
    },

    "audit_workflow_template": {
      "phase_1_scope_definition": [
        "Define exactly what to audit (files, endpoints, configs, etc.)",
        "List all sources of truth to compare against",
        "Create explicit checklist of verification items"
      ],
      "phase_2_bidirectional_search": [
        "Direction A‚ÜíB: Check source A against target B",
        "Direction B‚ÜíA: Check target B against source A",
        "Document both forward and reverse findings separately"
      ],
      "phase_3_tool_validation": [
        "If any search returns unexpected/empty: STOP",
        "Validate tool output with direct Read/inspection",
        "Switch to validated method if tool failed"
      ],
      "phase_4_gap_analysis": [
        "Documented but not implemented ‚Üí Missing implementations",
        "Implemented but not documented ‚Üí Missing docs",
        "Mismatches ‚Üí Discrepancies to resolve"
      ],
      "phase_5_reporting": [
        "Provide counts and metrics (X checked, Y found, Z missing)",
        "List specific findings with file:line references",
        "Include validation method used for each finding",
        "State assumptions and limitations explicitly"
      ]
    },

    "incident_lesson_2025_11_11": {
      "task": "User requested backend audit to verify brain/ documentation accuracy",
      "what_went_wrong": [
        "Only searched documented ‚Üí backend (found missing GET /bets/all)",
        "Did NOT search backend ‚Üí documented (missed 3 wallet financial endpoints)",
        "Grep failed with syntax error, did not validate with Read",
        "Assumed 'empty grep result = endpoint does not exist'"
      ],
      "impact": [
        "Reported 'Finance endpoints need implementation' when they already existed",
        "Wasted user's time asking for decision on implementation",
        "Only discovered endpoints existed when implementing 'new' endpoints"
      ],
      "root_cause": "Unidirectional search + tool failure without validation + assumption without verification",
      "correct_approach": [
        "Step 1: List all backend routes (ls backend/src/routes/*.ts)",
        "Step 2: For each route file, grep all router.get/post/put/delete",
        "Step 3: Compare against brain/api_endpoints_reference.json paths",
        "Step 4: Direction A: brain ‚Üí backend (missing implementations)",
        "Step 5: Direction B: backend ‚Üí brain (missing documentation)",
        "Step 6: If grep fails, Read file directly with offset/limit",
        "Step 7: Report both directions with counts"
      ]
    },

    "enforcement_checklist": {
      "before_concluding_audit": [
        "‚úÖ Both directions searched (A‚ÜíB AND B‚ÜíA)",
        "‚úÖ Tool outputs validated (especially empty/unexpected results)",
        "‚úÖ Complete enumeration performed (not sampling)",
        "‚úÖ Direct inspection used for critical findings",
        "‚úÖ Assumptions explicitly stated and validated",
        "‚úÖ Report includes metrics (X total, Y verified, Z discrepancies)"
      ],
      "red_flags_to_stop_and_validate": [
        "üö® Grep returns 0 results when you expected matches",
        "üö® Tool command exits without output or with error",
        "üö® Finding seems inconsistent with known system architecture",
        "üö® Only checked one direction of A vs B comparison",
        "üö® Relying on assumptions not explicitly verified"
      ]
    },

    "applicability": "All AIs performing audits, analysis, verification, or 'confirm X matches Y' tasks"
  },

  "role_responsibilities": {
    "director": {
      "primary": "Validation engine + architecture oversight + execution_mode declaration + task delegation to executors.",
      "mandatory": [
        "Declare model and role at session start: 'Model: [model_name] | Assigned Role: director | Mode: standard'",
        "TypeScript compilation after each executor session",
        "App.tsx routing verification for new pages",
        "Import/export dependency resolution",
        "Integration testing and gap filling",
        "Brain system updates with lessons learned",
        "Acknowledge and adhere to the current 'execution_mode' (trusted/standard) defined in the strategy.",
        "Delegate tasks to executors with clear, bounded instructions and file lists."
      ]
    },
    "executor": {
      "primary": "Backend API modifications or React component implementations (20-30 min sessions only). Operates under a plan from the director.",
      "mandatory": [
        "Declare model and role at session start: 'Model: [model_name] | Assigned Role: executor'",
        "ACTIVATE required MCPs BEFORE starting work (e.g., --seq for backend, --c7 for frontend).",
        "SIMULATE + CONFIRM protocol for all changes (unless in trusted mode for low complexity).",
        "npm install BEFORE using new libraries",
        "npx tsc --noEmit AFTER all code changes",
        "git diff --name-only BEFORE commit to verify scope",
        "Acknowledge and adhere to the current 'execution_mode' (trusted/standard) defined in the strategy.",
        "Report completion back to the director or user as specified."
      ],
      "forbidden": [
        "Making architecture decisions without director approval",
        "Modifying core files (e.g., Auth.ts, models, migrations) without explicit director approval",
        "Modifying files outside the provided [FILES_TO_MODIFY] list",
        "Committing code without TypeScript validation"
      ]
    }
  },

  "execution_workflows": {
    "simulate_y_confirmar_protocol": {
      "when": "Executor AI is about to modify code (routes, models, components, etc.).",
      "applicability_condition": "Applies if: execution_mode is 'standard' OR task.complexity is 'HIGH'.",
      "step_1_simulate": "Describe exactly what you'll change: files, imports, dependencies, test commands",
      "step_2_confirm": "Verify against actual codebase: Does file exist? Are imports available? Will this break anything?",
      "step_3_document": "[SIMULATED] ‚Üí [CONFIRMED] ‚Üí [MODIFIED] in commit message",
      "failure": "If simulation reveals problem ‚Üí REPORT it, do NOT attempt fix. Message: '[SIMULATION FAILED] Cannot [task]: Reason: [why] / Recommendation: [solution]'",
      "trusted_mode_exception": "In 'trusted' mode for complexity='LOW', this protocol can be skipped, but changes must still be verified with git diff before commit."
    },
    "checkpoint_system": {
      "when": "After any executor session creates/modifies pages",
      "verify": [
        "App.tsx routes: All created pages have Route entries?",
        "AdminSidebar.tsx: All admin pages have sidebar entries?",
        "Build passes: npm run build succeeds (unless skipped in trusted mode)?",
        "Commit has [WIRED] or [VERIFIED] tag?"
      ],
      "incident": "2025-10-18: Pages created but routes disappeared in intermediate commits"
    },
    "role_based_pipeline": {
      "phase_1_director_planning": "Director AI analyzes task, creates a detailed plan, and delegates to an executor.",
      "phase_2_executor_implementation": "Executor AI (Qwen/Gemini/etc.) implements the bounded task based on the plan.",
      "phase_3_director_validation": "Director AI validates the implementation, runs tests, updates the brain, and closes the loop."
    }
  },

  "validation_gates": {
    "role_and_model_appropriateness": {
      "check": "Is the model appropriate for the assigned role?",
      "validation_method": "Check 'ai_roles_and_preferences' to ensure the model is in 'preferred_models' and not in 'forbidden_models' for its role.",
      "enforcement": "First action of EVERY session: Model and role declaration + appropriateness verification.",
      "failure": "Session cannot proceed - recommend model/role switch to user."
    },
    "flag_activation_verification": {
      "when": "Before ANY code modification or database work",
      "required_declarations": [
        "Database/SQL work ‚Üí Must show: 'Activating --c7 --context7'",
        "Multi-step backend ‚Üí Must show: 'Activating --seq --sequential'",
        "React/TypeScript ‚Üí Must show: 'Activating --c7 --context7'",
        "UI testing ‚Üí Must show: 'Activating --play --playwright'"
      ],
      "verification_method": "AI must OUTPUT activation statement BEFORE starting work",
      "enforcement": "If AI starts work without declaring flags ‚Üí INVALID SESSION",
      "user_detection": "If no flag declaration in first 3 messages ‚Üí interrupt and ask AI to restart properly"
    },
    "typescript_compilation": {
      "command": "npx tsc --noEmit",
      "required": "ZERO errors. This gate is NEVER skippable, regardless of execution_mode.",
      "failure": "Stop session immediately, rollback, escalate to director AI"
    },
    "build_process": {
      "command": "npm run build",
      "required": "Successful completion in dist/.",
      "trusted_mode_exception": "In 'trusted' mode for low-risk UI-only changes (e.g., CSS, text content), this gate can be skipped after TypeScript validation passes. User must be informed.",
      "failure": "Full session rollback required (if not skipped)"
    },
    "dependency_check": {
      "command": "git diff HEAD package.json && npm install",
      "required": "All deps installed before using them",
      "enforcement": "Critical for executor AI (broke backend on 2025-10-14)"
    },
    "scope_validation": {
      "command": "git diff --name-only",
      "required": "ONLY files in [FILES_TO_MODIFY] changed",
      "failure": "REVERT scope violations before commit"
    }
  },

  "failure_recovery": {
    "unplanned_changes_analysis": {
      "detect": "git diff shows files outside AI task scope",
      "classify_as": {
        "error": "Syntax errors, broken builds, TODOs ‚Üí REVERT immediately",
        "destructive": "Breaks APIs, changes types, schema mods ‚Üí REVERT + investigate",
        "improvement": "ESLint formatting, code quality, performance ‚Üí RETAIN with [APPROVED_IMPROVEMENT] tag"
      }
    },
    "build_stability": {
      "typescript_fails": "Stop AI, rollback, document error patterns",
      "build_fails": "Full session rollback: git reset --hard HEAD~1",
      "imports_broken": "Fix paths immediately before proceeding"
    },
    "git_stash_safety": {
      "rule": "NEVER stash user's changes without explicit permission",
      "action": "ASK FIRST: 'About to stash [files]. OK?'",
      "document": "If stashing, record in brain/ with recovery command"
    }
  },

  "recommended_practices_optimization": {
    "system_maintenance_and_health_checks": {
      "description": "Best practices for the human operator to ensure the strategy file remains healthy and effective.",
      "strategies": [
        "Create a simple validation script (e.g., in Node.js or Python) that runs before starting AI work.",
        "The script should: a) Validate the JSON syntax of this file. b) Check if files referenced in 'tested_in_files' or other paths actually exist.",
        "Schedule a monthly review of the 'lessons_learned' sections to see if they can be generalized or if new patterns have emerged."
      ]
    },
    "strategies_for_perfect_json_work_plans": {
      "comprehensive_planning": [
        "Include all required file reads before starting work",
        "Identify dependencies and potential conflicts",
        "Define success criteria clearly",
        "List validation steps before implementation",
        "Plan for error handling and edge cases"
      ],
      "structured_formatting": [
        "Use consistent JSON structure with clear metadata",
        "Include file paths, required changes, and expected outcomes",
        "Document test commands and validation gates",
        "Provide fallback plans if primary approaches fail",
        "Specify rollback procedures for safety"
      ],
      "error_prevention": [
        "Pre-verification of all assumptions with codebase analysis",
        "Type compatibility checks before implementation",
        "Scope validation to prevent unwanted side effects",
        "Dependency mapping to understand impact of changes",
        "Mandatory TypeScript compilation after changes"
      ],
      "quality_assurance": [
        "Zero 'any' types enforcement in TypeScript projects",
        "Consistent pattern application across similar components",
        "Integration testing with existing codebase",
        "Performance impact analysis for database changes",
        "Security validation for user-facing features"
      ]
    },
    "json_plan_template": {
      "metadata": {
        "task_name": "Brief, descriptive task name",
        "complexity": "LOW/MEDIUM/HIGH",
        "execution_mode": "standard/trusted (to be decided by director)",
        "assigned_role": "director/executor",
        "estimated_time": "Minutes",
        "git_branch": "Target branch for work"
      },
      "critical_protocols": {
        "session_start_declaration": "Model and role declaration with task type and flags",
        "mcp_activation_mandatory": "Required MCPs for the specific task type",
        "simulate_confirm_protocol": "Explicit simulation and confirmation steps",
        "no_file_creation": "Restrictions on what can be created vs modified",
        "infinite_loop_prevention": "Prevention mechanisms for common loops"
      },
      "reference_files_read_first": [
        "List of required files to read before implementation",
        "Documentation that provides context",
        "Current implementations for consistency"
      ],
      "step_by_step_implementation": {
        "step_number": {
          "action": "Specific action to take",
          "file": "Target file for the action",
          "purpose": "Why this step is needed",
          "simulate": "What will be done in simulation phase",
          "confirm_before_creating": "What to verify before proceeding",
          "validate_after_creation": "How to validate the change"
        }
      },
      "success_criteria": [
        "Zero TypeScript errors",
        "Build process succeeds (if applicable)",
        "No 'any' types introduced",
        "Files modified only as specified",
        "All features implemented correctly"
      ],
      "error_handling": {
        "typescript_errors": "Stop immediately if compilation fails",
        "build_errors": "Do not commit if build fails",
        "infinite_loop_detection": "Stop if same file edited multiple times"
      }
    },
    "general_lessons_learned": {
      "pre_implementation_validation": {
        "description": "Always validate assumptions and read relevant files BEFORE implementation",
        "strategies": [
          "Read type/interface definitions before implementing functions",
          "Verify API signatures exist before calling them",
          "Check import paths and dependencies before starting work",
          "Understand the full scope of changes to prevent incomplete implementations"
        ]
      },
      "incremental_development": {
        "description": "Break complex tasks into smaller, verifiable steps",
        "strategies": [
          "Implement and test one feature at a time",
          "Use checkpoints to validate progress",
          "Verify each step before moving to the next",
          "Roll back immediately if any step fails validation"
        ]
      },
      "consistency_enforcement": {
        "description": "Maintain consistent patterns across the codebase",
        "strategies": [
          "Follow established naming conventions",
          "Use consistent component structures and props",
          "Apply uniform error handling patterns",
          "Maintain consistent data flow and state management"
        ]
      },
      "error_prevention_patterns": {
        "description": "Proactive strategies to prevent common implementation errors",
        "strategies": [
          "Type safety: Avoid 'any' types, use explicit interfaces",
          "Null safety: Use optional chaining and null checks",
          "API validation: Verify endpoints exist before implementation",
          "Dependency checking: Ensure all imports are available before use"
        ]
      }
    }
  },

  "business_model_clarifications_2025_10_30": {
    "events_venues": {
      "definition": "Events are competitions held AT venues (stadiums). events.venue_id ‚Üí user with role='venue'",
      "rule": "ONLY role='venue' users can host events. Not galleras, not regular users.",
      "semantic": "venue_id means 'physical location', not 'arbitrary owner'"
    },
    "articles_authors": {
      "definition": "Articles created BY users (admin/venue/gallera). articles.author_id ‚Üí creator",
      "rule": "Regular users CANNOT create articles. Only admin/venue/gallera roles.",
      "deprecated": "articles.venue_id should be removed after data consolidation"
    },
    "principle": "Foreign keys represent SEMANTIC relationships, not just type compatibility. Verify the MEANING, not just the data types."
  },

  "executor_scope_creep_prevention_2025_10_19": {
    "incident": "Executor AI modified files outside scope (Administrators.tsx, Dashboard.tsx, News.tsx) with valid ESLint improvements",
    "root_cause": "[FILES_TO_MODIFY] lacked strong enforcement language",
    "prevention": [
      "Add to executor prompts: 'üî¥ NEVER modify any file NOT in [FILES_TO_MODIFY] list'",
      "Add: 'If you see opportunity to improve other files ‚Üí STOP and document it, do NOT change'",
      "Add: 'BEFORE commit: Run git diff --name-only and verify ONLY approved files changed'",
      "Add: 'IF tempted ‚Üí Report as [OUT_OF_SCOPE] and let the director decide'"
    ]
  },

  "filter_logic_best_practices_2025_10_30": {
    "incident": "Executor AI created Op.or filter conflict: search and subscription filters overwrote each other instead of combining",
    "root_cause": "Sequelize pattern: Assignment to where[Op.or] twice = second overwrites first",
    "lesson_for_all_ais": "When building MULTIPLE filter conditions in ORM queries, understand whether filters should be COMBINED or SEPARATE",
    "solution_pattern": {
      "problem": "‚ùå Multiple assignments to same operator key overwrites previous value",
      "code_example_wrong": "if (search) { where[Op.or] = [...search conditions]; } if (subscription) { where[Op.or] = [...subscription conditions]; } // Second overwrites first!",
      "solution_approach": "‚úÖ Create conditions array and push each filter condition, then combine with Op.and at the end",
      "code_example_correct": "const conditions = []; if (search) { conditions.push({ [Op.or]: [...] }); } if (subscription) { conditions.push({ [Op.or]: [...] }); } if (conditions.length > 0) { where[Op.and] = conditions; }",
      "semantic_rule": "Op.and wraps multiple filter objects. Op.or applies WITHIN a single condition. Combining filters = Op.and(filter1, filter2, filter3)"
    },
    "prevention": [
      "When combining multiple independent filters (search + subscription + status + etc): use conditions[] pattern",
      "Each filter gets its own [Op.or] for internal options, but filters combine via [Op.and]",
      "BEFORE implementing: Sketch the filter logic: (search_term OR search_email) AND (subscription_free OR subscription_expired) AND ...",
      "TEST: Verify filters work INDEPENDENTLY and COMBINED. Don't test only one at a time.",
      "VALIDATE: Check git diff to see actual SQL pattern - should see Op.and wrapping Op.or conditions"
    ],
    "applicability": "Sequelize ORM, other ORMs with similar pattern logic",
    "tested_in_files": [
      "backend/src/routes/users.ts:67-140 (search + subscriptionType filters)",
      "backend/src/routes/venues.ts:72-145 (search + ownerSubscription filters)",
      "backend/src/routes/galleras.ts:49-122 (search + ownerSubscription filters)"
    ]
  },

  "task_disambiguation_protocol_2025_11_04": {
    "incident": "Executor AI executed different tasks than assigned: PAGO/DOY UI instead of INFRINGEMENT fixes, causing scope mismatch",
    "root_cause_analysis": {
      "ambiguous_task_identifiers": "Task numbers (TASK_3, TASK_4) conflicted with other project task numbers",
      "implicit_prioritization": "AI reinterpreted priorities without explicit confirmation",
      "missing_verification_checkpoint": "No 'echo back assigned tasks' step at session start"
    },
    "generalized_prevention_strategies": [
      "üî¥ MANDATORY: AI must ECHO BACK task assignments at session start",
      "Use unique task identifiers: Include date/session ID (e.g., TASK_2025_11_04_A, TASK_SESSION_6_ITEM_1)",
      "Explicit task titles in addition to numbers (e.g., TASK_3_INFRINGEMENT_FIXES not just TASK_3)",
      "Verification checkpoint format: 'I will execute: [TASK_ID]: [DESCRIPTION]. Confirm Y/N?'",
      "If AI detects conflicting priorities ‚Üí STOP and ask user which takes precedence"
    ],
    "applicability": "All AI sessions (especially executors) when receiving multi-task assignments"
  },

  "reporting_location_protocol_2025_11_04": {
    "incident": "Executor AI reported completion to user via text, did not update brain/backlog.json as required",
    "root_cause_analysis": {
      "implicit_instructions": "Prompt said 'report completion' but didn't specify WHERE",
      "competing_priorities": "AI prioritized quick user feedback over structured documentation",
      "missing_completion_checklist": "No explicit final step to update brain files"
    },
    "generalized_prevention_strategies": [
      "üî¥ MANDATORY: Specify EXACT file path for reporting (e.g., 'Update /home/user/project/brain/backlog.json line 450')",
      "Completion checklist in prompt: 'BEFORE considering task complete: 1) Update backlog.json 2) Commit changes 3) Report to user'",
      "Report format specification: Provide JSON structure or template AI must follow",
      "Verification command: Include 'git diff brain/backlog.json' to confirm update happened",
      "If uncertain WHERE to report ‚Üí ASK user explicitly, do NOT assume"
    ],
    "enforcement": {
      "prompt_template": "üìù REPORTING PROTOCOL: After completing all tasks, you MUST update [EXACT_FILE_PATH] with structured report following [TEMPLATE]. Verify with git diff before final commit.",
      "user_validation": "User should check brain/ files after AI session to confirm documentation updated"
    },
    "applicability": "All AI sessions requiring documentation updates (executor work sessions)"
  },

  "session_context_loss_prevention_2025_11_04": {
    "observation": "Long executor sessions may lose context, causing incomplete implementations or missed requirements",
    "prevention_strategies": [
      "Session length limits: Executor AI max 30-40 minutes or ~15K tokens output",
      "Checkpoint saves: Every 15 minutes, AI commits progress with '[CHECKPOINT]' tag",
      "Context refresh protocol: If session exceeds 30 min ‚Üí User closes session, AI writes handoff note, new session starts fresh",
      "Reference file reminders: Every 5 tasks, AI re-reads critical reference files (types, API docs, etc.)",
      "Memory externalization: AI writes 'working_state.json' in brain/ with current progress for session resume"
    ],
    "handoff_note_format": {
      "completed": "List of finished tasks with file paths",
      "in_progress": "Current task with specific line numbers being edited",
      "next_steps": "Remaining tasks in priority order",
      "blockers": "Any issues encountered requiring attention",
      "reference_files": "Which files new session should read first"
    },
    "applicability": "All AI sessions, especially executor (primary implementation role with longer sessions)"
  },

  "evidence_based_validation_protocol": {
    "principle": "Trust but verify - Never accept completion claims without independent validation",
    "director_responsibilities": [
      "Run validation commands independently after executor work: npx tsc --noEmit, npm run build, npm run dev",
      "Compare actual state against executor claims (error counts, file changes, functionality)",
      "Validate changes align with brain reference files (prd_system.json, api_endpoints_reference.json, typescript_interfaces_reference.json)",
      "Reject vague claims like 'fixed 40 errors' without specific before/after evidence"
    ],
    "executor_responsibilities": [
      "Provide concrete evidence in completion reports: command outputs, specific file/line changes, test results",
      "Never report success without running verification commands yourself first",
      "Include before/after states for measurable claims (error counts, build status, etc.)",
      "Document specific changes made (git diff --stat, list of modified functions/components)"
    ],
    "validation_checklist": [
      "TypeScript compilation: npx tsc --noEmit returns 0 errors",
      "Build process: npm run build completes successfully",
      "Runtime: npm run dev starts without errors",
      "Brain alignment: Changes match PRD requirements and API contracts",
      "Scope adherence: Only approved files modified (git diff --name-only verification)"
    ],
    "backlog_update_requirements": [
      "Include verification_evidence field with actual command outputs",
      "List specific files modified with line count changes",
      "Provide measurable metrics (errors fixed, features added, tests passing)",
      "Link to brain reference files that guided the work"
    ],
    "enforcement": "Director AI validates executor work before updating backlog. User should verify director validation independently."
  },

  "next_sessions": {
    "protocol_enforcement": "All AIs must follow mandatory_reads_at_start, exit_infinite_loops_protocol, role_and_model_awareness_protocol, AND evidence_based_validation_protocol",
    "role_and_model_verification": "CRITICAL: All AIs must declare model and ASSIGNED ROLE in first message. User should interrupt if missing.",
    "coordination_strategy": "Director AI orchestrates, delegates tasks to executor AI. The specific model instance (Claude, GLM, Qwen, Gemini) is a configuration choice based on the 'ai_roles_and_preferences' section.",
    "prompt_files_location": "Read [role]-prompt.json from PROJECT ROOT (not brain/) for task-specific instructions.",
    "mandatory_protocols_all_sessions": [
      "Role and model declaration at session start",
      "Task echo-back verification at session start",
      "Exact file path for reporting specified in prompts",
      "Completion checklist with brain/ update as mandatory step",
      "Session length monitoring with checkpoint commits every 15 min",
      "Acknowledgement of 'execution_mode' and conditional protocol application",
      "Evidence-based validation - Director verifies executor claims with actual command execution",
      "Backlog updates include verification_evidence field with command outputs"
    ]
  },

  "lesson_learned_never_simulate_results": {
    "critical_error_pattern": "Simulating or fabricating test results and reporting them as real outcomes",
    "incident_description": "An executor AI simulated E2E test results before actual execution, potentially compromising data integrity and trust",
    "impact": [
      "Misleading stakeholders about system readiness",
      "Wasting development time when fake results are discovered",
      "Causing real problems to be overlooked due to false positive reports",
      "Damaging trust in AI-generated reports and validations"
    ],
    "prevention_measures": {
      "never_prepopulate_results": {
        "rule": "NEVER create or simulate results before actually performing the tests or validations",
        "implementation": "Only document actual, observable results after tests have been executed",
        "enforcement": "AI systems must report only what has been physically verified or validated"
      },
      "evidence_based_reporting": {
        "principle": "Always report actual test results, not anticipated or desired outcomes",
        "practice": "Run tests first, then document what actually happened (success or failure)",
        "verification": "Include actual command outputs, error messages, or specific validation results"
      },
      "transparency_practice": {
        "principle": "Be transparent about test status - failed tests are valuable information",
        "practice": "Report test failures honestly, as they reveal important issues that need fixing",
        "benefit": "Failing tests provide valuable information for improving system quality"
      }
    },
    "validation_strategy": {
      "before_reporting_completion": [
        "Verify all claimed test results were actually executed",
        "Confirm all evidence is from real test runs, not anticipated outcomes",
        "Validate that failed tests are acknowledged and documented appropriately",
        "Ensure all metrics reported are from actual system behavior"
      ]
    },
    "applicability": "All AI sessions involving testing, validation, monitoring, or reporting of system behavior",
    "enforcement": "Any AI found fabricating or simulating results before actual execution must stop immediately, acknowledge the error, and perform the actual tests or validations requested."
  }
}