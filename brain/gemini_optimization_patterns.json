{
  "metadata": {
    "purpose": "Gemini-specific implementation patterns for GalloBets React/TypeScript development",
    "created": "2025-09-21",
    "based_on": "Sistema-agri patterns + GalloBets specific requirements",
    "project": "GalloBets - Professional Cockfighting Streaming Platform",
    "optimization_focus": "React excellence, TypeScript mastery, SSE integration"
  },

  "gemini_excellence_patterns": {
    "react_typescript_mastery": {
      "component_architecture_patterns": {
        "pattern": "Functional components with TypeScript + proper typing",
        "evidence": "Professional React patterns from sistema-agri success",
        "leverage_for": [
          "Complex betting components",
          "Real-time SSE integration",
          "Admin/Operator dashboards",
          "Responsive betting panels"
        ],
        "implementation_template": {
          "typescript_interfaces": "Define all props and state types explicitly",
          "custom_hooks": "useSSE, useBettingWindow, useOperatorPermissions",
          "error_boundaries": "Wrap critical components for stability",
          "memo_optimization": "React.memo for performance critical components"
        }
      },

      "sse_integration_excellence": {
        "pattern": "EventSource management with automatic reconnection",
        "specific_to_gallobets": "Admin real-time updates without WebSocket complexity",
        "implementation_patterns": {
          "useSSE_hook": {
            "structure": "Custom hook with reconnection logic",
            "error_handling": "Automatic retry with exponential backoff",
            "cleanup": "Proper EventSource cleanup on unmount",
            "typing": "Generic TypeScript for event data types"
          },
          "real_time_components": {
            "SystemMonitoring": "Live system stats via SSE",
            "BettingPanel": "Real-time bet updates",
            "FightStatus": "Live fight transitions",
            "OperatorNotifications": "Instant admin alerts"
          }
        }
      },

      "betting_ui_patterns": {
        "pattern": "P2P betting interface with temporal logic",
        "gallobets_specific": "Fight windows, PAGO/DOY proposals, countdown timers",
        "components": {
          "CurrentBettingPanel": {
            "features": ["Live bet updates", "Create bet modal", "Filter/sort options"],
            "sse_integration": "Subscribe to fight-specific events",
            "state_management": "Local state + SSE updates",
            "responsiveness": "Mobile-first with Tailwind"
          },
          "BetCard": {
            "features": ["Accept/Reject buttons", "Bet details display", "User info"],
            "animations": "Smooth transitions for updates",
            "accessibility": "Keyboard navigation support"
          },
          "PAGODOYModal": {
            "features": ["Proposal creation", "3-min countdown", "Accept/reject"],
            "websocket": "Minimal WebSocket for proposals only",
            "validation": "Amount limits, timeout handling"
          }
        }
      }
    },

    "gallobets_domain_excellence": {
      "cockfighting_business_understanding": {
        "pattern": "Domain-specific UI patterns for galleras",
        "evidence": "Correct interpretation of fight windows and betting logic",
        "leverage_for": [
          "Fight status transitions UI",
          "Betting window indicators",
          "Operator event management",
          "Streaming controls"
        ],
        "domain_patterns": {
          "fight_temporal_flow": "Visual indicators for upcoming→betting→live→completed",
          "betting_windows": "Clear open/close states with countdown",
          "operator_hierarchy": "Role-based UI conditionals",
          "event_management": "Multi-fight event coordination"
        }
      },

      "streaming_integration_ui": {
        "pattern": "RTMP streaming controls and monitoring",
        "gallobets_requirements": "OBS integration, HLS delivery monitoring",
        "components": {
          "StreamingControls": {
            "features": ["Start/stop stream", "RTMP key display", "Quality settings"],
            "monitoring": "Bitrate, viewers, connection status",
            "operator_limits": "Only for assigned events"
          },
          "StreamViewer": {
            "features": ["HLS player integration", "Quality selection", "Fullscreen"],
            "subscription_check": "Validate user access",
            "fallback": "Error states for stream issues"
          }
        }
      }
    },

    "ui_ux_implementation_excellence": {
      "responsive_design_patterns": {
        "pattern": "Mobile-first with Tailwind CSS",
        "breakpoints": {
          "mobile": "Default styles",
          "tablet": "md: prefix (768px+)",
          "desktop": "lg: prefix (1024px+)",
          "wide": "xl: prefix (1280px+)"
        },
        "gallobets_layouts": {
          "betting_panel": "Stack on mobile, grid on desktop",
          "admin_dashboard": "Collapsible sidebar pattern",
          "operator_interface": "Tab navigation on mobile",
          "fight_display": "Card layout responsive grid"
        }
      },

      "tailwind_component_patterns": {
        "pattern": "Consistent design system with Tailwind",
        "color_scheme": {
          "primary": "blue-600 (main actions)",
          "success": "green-600 (completed bets)",
          "danger": "red-600 (reject/close)",
          "warning": "yellow-600 (PAGO proposals)",
          "neutral": "gray-600 (secondary elements)"
        },
        "component_classes": {
          "buttons": "px-4 py-2 rounded-lg font-medium transition-colors",
          "cards": "bg-white rounded-lg shadow-md p-4",
          "inputs": "border rounded-lg px-3 py-2 focus:ring-2",
          "modals": "fixed inset-0 bg-black bg-opacity-50 flex items-center"
        }
      },

      "animation_patterns": {
        "pattern": "Smooth transitions for real-time updates",
        "implementations": {
          "bet_updates": "fade-in for new bets",
          "status_changes": "slide transition between states",
          "countdown_timers": "smooth progress bars",
          "notifications": "slide-in from top-right"
        }
      }
    }
  },

  "gemini_gap_prevention_protocols": {
    "sse_implementation_gaps": {
      "potential_problem": "Incomplete EventSource error handling",
      "prevention_strategy": {
        "error_scenarios": [
          "Connection lost → Automatic reconnection",
          "Invalid data → Graceful error display",
          "Server down → Fallback to polling",
          "Auth expired → Re-authenticate"
        ],
        "testing_checklist": [
          "☐ Test connection loss recovery",
          "☐ Verify reconnection backoff",
          "☐ Check memory leak prevention",
          "☐ Validate cleanup on unmount"
        ]
      }
    },

    "typescript_typing_gaps": {
      "potential_problem": "Incomplete type definitions leading to 'any'",
      "prevention_strategy": {
        "type_requirements": [
          "All API responses fully typed",
          "Event data types defined",
          "Component props strictly typed",
          "State interfaces complete"
        ],
        "validation_process": [
          "Run tsc --noEmit after changes",
          "Fix any TypeScript errors immediately",
          "No @ts-ignore comments",
          "Strict mode enabled"
        ]
      }
    },

    "component_integration_gaps": {
      "potential_problem": "Components not properly integrated with SSE/API",
      "prevention_strategy": {
        "integration_checklist": [
          "☐ SSE subscription established",
          "☐ Error states handled",
          "☐ Loading states shown",
          "☐ Data updates reflected",
          "☐ Cleanup on unmount"
        ],
        "testing_requirements": [
          "Test with real backend",
          "Verify SSE events received",
          "Check state updates",
          "Validate UI reflects changes"
        ]
      }
    }
  },

  "gallobets_specific_patterns": {
    "betting_window_components": {
      "FightWindowIndicator": {
        "purpose": "Show current fight betting status",
        "implementation": `
const FightWindowIndicator: React.FC<{ fight: Fight }> = ({ fight }) => {
  const [timeRemaining, setTimeRemaining] = useState<number>(0);
  
  useEffect(() => {
    if (fight.status === 'betting' && fight.bettingEndsAt) {
      const timer = setInterval(() => {
        const remaining = new Date(fight.bettingEndsAt).getTime() - Date.now();
        setTimeRemaining(Math.max(0, remaining));
        
        if (remaining <= 0) {
          clearInterval(timer);
        }
      }, 1000);
      
      return () => clearInterval(timer);
    }
  }, [fight]);
  
  const formatTime = (ms: number) => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    return \`\${minutes}:\${(seconds % 60).toString().padStart(2, '0')}\`;
  };
  
  return (
    <div className={\`
      px-4 py-2 rounded-lg font-medium
      \${fight.status === 'betting' ? 'bg-green-100 text-green-800' : ''}
      \${fight.status === 'upcoming' ? 'bg-blue-100 text-blue-800' : ''}
      \${fight.status === 'live' ? 'bg-red-100 text-red-800' : ''}
      \${fight.status === 'completed' ? 'bg-gray-100 text-gray-800' : ''}
    \`}>
      {fight.status === 'betting' && (
        <>Apuestas Abiertas - {formatTime(timeRemaining)}</>
      )}
      {fight.status === 'upcoming' && <>Próximamente</>}
      {fight.status === 'live' && <>En Vivo - Apuestas Cerradas</>}
      {fight.status === 'completed' && <>Finalizado</>}
    </div>
  );
};`
      },

      "CurrentBettingPanel": {
        "purpose": "Main betting interface for active fight",
        "key_features": [
          "SSE subscription for real-time updates",
          "Create new bet functionality",
          "Accept existing bet flow",
          "PAGO/DOY proposal handling"
        ],
        "sse_pattern": "Subscribe to /api/sse/fights/${fightId}/bets",
        "state_management": "Local state for UI + SSE for data"
      }
    },

    "operator_dashboard_patterns": {
      "OperatorEventManager": {
        "purpose": "Limited event management for operators",
        "restrictions": [
          "Can only see assigned events",
          "Cannot create new events",
          "Cannot modify user roles",
          "Can manage fights within events"
        ],
        "permission_checks": "Check operator permissions before rendering actions"
      },

      "FightControlPanel": {
        "purpose": "Operator controls for fight status",
        "features": [
          "Open/close betting windows",
          "Transition fight status",
          "View betting statistics",
          "Emergency stop betting"
        ],
        "validation": "Server validates operator has event access"
      }
    },

    "sse_hook_pattern": {
      "comprehensive_implementation": `
import { useEffect, useState, useRef, useCallback } from 'react';

interface UseSSEOptions {
  onMessage?: (data: any) => void;
  onError?: (error: Event) => void;
  onOpen?: () => void;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

function useSSE<T = any>(
  url: string,
  options: UseSSEOptions = {}
): {
  data: T | null;
  error: Error | null;
  isConnected: boolean;
  reconnect: () => void;
} {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  const eventSourceRef = useRef<EventSource | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const reconnectAttemptsRef = useRef(0);
  
  const {
    onMessage,
    onError,
    onOpen,
    reconnectInterval = 3000,
    maxReconnectAttempts = 10
  } = options;
  
  const connect = useCallback(() => {
    try {
      // Clean up existing connection
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
      
      // Create new EventSource
      const eventSource = new EventSource(url);
      eventSourceRef.current = eventSource;
      
      eventSource.onopen = () => {
        setIsConnected(true);
        setError(null);
        reconnectAttemptsRef.current = 0;
        onOpen?.();
      };
      
      eventSource.onmessage = (event) => {
        try {
          const parsedData = JSON.parse(event.data);
          setData(parsedData);
          onMessage?.(parsedData);
        } catch (err) {
          setError(new Error('Failed to parse SSE data'));
        }
      };
      
      eventSource.onerror = (event) => {
        setIsConnected(false);
        setError(new Error('SSE connection error'));
        onError?.(event);
        
        // Attempt reconnection
        if (reconnectAttemptsRef.current < maxReconnectAttempts) {
          reconnectAttemptsRef.current++;
          reconnectTimeoutRef.current = setTimeout(() => {
            connect();
          }, reconnectInterval * Math.pow(2, reconnectAttemptsRef.current - 1));
        }
      };
    } catch (err) {
      setError(err as Error);
      setIsConnected(false);
    }
  }, [url, onMessage, onError, onOpen, reconnectInterval, maxReconnectAttempts]);
  
  useEffect(() => {
    connect();
    
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
    };
  }, [connect]);
  
  const reconnect = useCallback(() => {
    reconnectAttemptsRef.current = 0;
    connect();
  }, [connect]);
  
  return { data, error, isConnected, reconnect };
}`
      }
    }
  },

  "coordination_protocols": {
    "pre_implementation": {
      "claude_deliverables_required": [
        "Complete SSE event type definitions",
        "API endpoint specifications",
        "Component prop interfaces",
        "Business logic validation rules",
        "Error handling requirements"
      ],
      "gemini_checklist": [
        "☐ Read all Claude specifications",
        "☐ Understand betting domain logic",
        "☐ Review existing components for patterns",
        "☐ Plan component hierarchy",
        "☐ Set up TypeScript interfaces"
      ]
    },

    "during_implementation": {
      "validation_points": [
        "Every 30 minutes: Test component renders",
        "After SSE integration: Verify events received",
        "After state changes: Check UI updates",
        "Before handoff: Full integration test"
      ],
      "common_issues": [
        "EventSource not closing properly → Memory leaks",
        "Missing TypeScript types → Use proper interfaces",
        "State not updating → Check SSE data parsing",
        "Components not responsive → Test all breakpoints"
      ]
    },

    "post_implementation": {
      "gemini_handoff_checklist": [
        "All components created and rendering",
        "TypeScript compilation successful",
        "SSE integration working",
        "Responsive design verified",
        "No console errors",
        "Basic functionality tested"
      ],
      "claude_validation_needs": [
        "Integration testing with backend",
        "Performance optimization if needed",
        "Security validation for operator limits",
        "Edge case handling verification"
      ]
    }
  },

  "quality_standards": {
    "code_quality": {
      "typescript": [
        "No 'any' types except where absolutely necessary",
        "Strict null checks enabled",
        "All props and state typed",
        "No @ts-ignore comments"
      ],
      "react_patterns": [
        "Functional components only",
        "Custom hooks for logic reuse",
        "Proper dependency arrays in useEffect",
        "Cleanup functions for subscriptions"
      ],
      "testing": [
        "Components should be testable",
        "Mock SSE for unit tests",
        "Integration tests with real backend",
        "Accessibility testing included"
      ]
    },

    "ui_ux_standards": {
      "responsiveness": [
        "Mobile-first approach",
        "Test on all breakpoints",
        "Touch-friendly on mobile",
        "Readable on all screen sizes"
      ],
      "accessibility": [
        "Semantic HTML elements",
        "ARIA labels where needed",
        "Keyboard navigation support",
        "Screen reader friendly"
      ],
      "performance": [
        "Lazy load heavy components",
        "Optimize re-renders with memo",
        "Debounce user inputs",
        "Virtual scrolling for long lists"
      ]
    }
  },

  "success_metrics": {
    "technical_excellence": {
      "react_quality": "5/5 - Professional patterns",
      "typescript_coverage": "100% - No untyped code",
      "sse_integration": "5/5 - Robust real-time updates",
      "responsiveness": "5/5 - Perfect on all devices"
    },
    "domain_implementation": {
      "betting_logic": "5/5 - Correct temporal windows",
      "operator_limits": "5/5 - Permissions enforced",
      "streaming_ui": "5/5 - Professional controls",
      "user_experience": "5/5 - Intuitive betting flow"
    },
    "coordination_effectiveness": {
      "handoff_quality": "5/5 - Clear communication",
      "integration_success": "5/5 - Works with backend",
      "timeline_adherence": "5/5 - Meets deadlines",
      "bug_rate": "Minimal - Well tested"
    }
  }
}