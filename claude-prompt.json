{
  "project": {
    "name": "Sistema de Suscripciones y Sanitizaci√≥n de Endpoints",
    "version": "1.0.0",
    "description": "Plan para corregir inconsistencias en suscripciones y aplicar sanitizaci√≥n de datos en endpoints p√∫blicos"
  },
  
  "ai_configuration": {
    "target_agents": ["gemini-cli", "claude-code"],
    "mcps_required": [
      "context7",
      "github",
      "filesystem", 
      "database"
    ],
    "reasoning_approach": "test_driven_development",
    "task_decomposition": "atomic_focused_tasks"
  },

  "architecture_context": {
    "backend": {
      "framework": "Node.js + Express + TypeScript",
      "orm": "Sequelize with PostgreSQL (Neon Tech)",
      "auth": "JWT with role-based permissions",
      "structure": "MVC pattern with middleware layers"
    },
    "frontend": {
      "framework": "React + TypeScript + Vite",
      "state": "Context API + hooks",
      "routing": "React Router",
      "styling": "Tailwind CSS"
    },
    "database": {
      "source_of_truth": "/backend/database-analysis/*.json",
      "naming": "snake_case in DB, camelCase in models",
      "relations": "Defined in models/index.ts"
    }
  },

  "coding_conventions": {
    "typescript": {
      "strict_mode": true,
      "explicit_return_types": "for public methods",
      "naming": "camelCase for variables/methods, PascalCase for classes"
    },
    "error_handling": {
      "backend": "asyncHandler wrapper + custom error classes",
      "frontend": "try/catch with user-friendly messages"
    },
    "validation": {
      "backend": "express-validator for inputs",
      "frontend": "form validation with error states"
    },
    "testing": {
      "backend": "Jest + Supertest for API tests",
      "frontend": "React Testing Library + Jest"
    }
  },

  "phases": [
    {
      "phase": 1,
      "title": "Correcci√≥n Sistema Suscripciones (CR√çTICO)",
      "priority": "HIGH",
      "estimated_time": "2-3 horas restantes", 
      "progress": "35% completado",
      "commit_v14_summary": {
        "completed": [
          "‚úÖ SUB-001: GET /users/profile incluye subscription (commit previo)",
          "‚úÖ User.getCurrentSubscription() m√©todo implementado (commit previo)", 
          "‚úÖ Rol 'gallera' agregado a frontend components",
          "‚úÖ SubscriptionManager.tsx componente nuevo",
          "‚úÖ Profile.tsx redise√±ado completo",
          "‚úÖ SubscriptionGuard.tsx mejorado",
          "‚úÖ ProtectedRoute incluye gallera role"
        ],
        "not_completed": [
          "‚ùå SUB-002: useSubscription hook A√öN usa subscriptionAPI en lugar de AuthContext",
          "‚ùå SUB-003: Headers/Profile NO muestran subscription status correcto",
          "‚ùå Database migration script NO aplicado"
        ],
        "critical_issue": "useSubscription.ts NO modificado - sigue causando inconsistencias"
      },
      "tasks": [
        {
          "id": "SUB-001",
          "title": "‚úÖ COMPLETADO - Unificar Respuesta Usuario con Suscripci√≥n",
          "description": "‚úÖ GET /api/users/profile ahora incluye informaci√≥n de suscripci√≥n activa",
          "status": "COMPLETED",
          "completion_notes": "Implementado en commit V12 con User.getCurrentSubscription() method",
          "files_modified": [
            "‚úÖ backend/src/routes/users.ts - Endpoint profile incluye subscription",
            "‚úÖ backend/src/models/User.ts - M√©todo getCurrentSubscription() agregado"
          ],
          "implemented_features": [
            "‚úÖ GET /api/users/profile devuelve { user, wallet, subscription }",
            "‚úÖ User.getCurrentSubscription() maneja l√≥gica free/premium",
            "‚úÖ Formato normalizado: type free/daily/monthly",
            "‚úÖ Compatibilidad mantenida con frontend actual"
          ],
          "verification_needed": [
            "üß™ Tests unitarios para User.getCurrentSubscription()",
            "üß™ Tests integraci√≥n para endpoint profile con subscription",
            "üß™ Verificar casos edge: usuario sin subscription"
          ]
        },
        {
          "id": "SUB-001C",
          "title": "‚úÖ COMPLETADO PREVIAMENTE - Endpoints Admin Usuarios",
          "description": "‚úÖ Endpoints para gesti√≥n admin ya exist√≠an en commits anteriores",
          "status": "COMPLETED", 
          "completion_notes": "Endpoints ya estaban implementados antes de V14, no fueron agregados en V14",
          "files_existing": [
            "‚úÖ backend/src/routes/users.ts - Endpoints activation/role preexistentes"
          ],
          "existing_features": [
            "‚úÖ PUT /api/users/:id/activation - Ya funcional",
            "‚úÖ PUT /api/users/:id/role - Ya funcional", 
            "‚úÖ GET /api/users/operators/available - Ya funcional",
            "‚úÖ Logs de auditor√≠a - Ya implementados"
          ]
        }
,
        {
          "id": "SUB-002", 
          "title": "üîÑ ACTUALIZADO - Corregir Hook useSubscription",
          "description": "Usar datos de subscription desde AuthContext/profile en lugar de endpoint separado",
          "files_to_modify": [
            "frontend/src/hooks/useSubscription.ts",
            "frontend/src/contexts/AuthContext.tsx"
          ],
          "purpose": "Eliminar inconsistencias usando datos unificados de /api/users/profile",
          "requirements": [
            "useSubscription debe leer subscription desde AuthContext.user",
            "AuthContext debe incluir subscription en fetchUser desde /api/users/profile",
            "Mantener interfaz actual para compatibilidad con componentes",
            "Sincronizar actualizaci√≥n subscription cuando user data cambia"
          ],
          "current_issue": "useSubscription hook a√∫n usa subscriptionAPI.getCurrentSubscription() que llama /api/subscriptions/current",
          "solution_approach": "Obtener subscription desde user.subscription en AuthContext",
          "inputs": {
            "context": "AuthContext.user.subscription desde /api/users/profile",
            "fallback": "subscription null para usuarios no autenticados"
          },
          "outputs": {
            "hook_return": {
              "subscription": "User.subscription | null",
              "hasAccess": "boolean basado en type !== 'free' && status === 'active'",
              "isPremium": "boolean alias de hasAccess", 
              "loading": "boolean desde AuthContext loading",
              "error": "string | null desde AuthContext error",
              "refreshAccess": "() => AuthContext.fetchUser()"
            }
          },
          "implementation_steps": [
            "1. Modificar AuthContext para parsear subscription de /api/users/profile",
            "2. Cambiar useSubscription para leer user.subscription en lugar de API call",
            "3. Actualizar l√≥gica hasAccess: type !== 'free' && status === 'active' && no expired",
            "4. Remover subscriptionAPI calls del hook",
            "5. Tests para verificar sincronizaci√≥n AuthContext ‚Üî useSubscription"
          ]
        },
        {
          "id": "SUB-003",
          "title": "Actualizar Headers y Profile con Tipo de Plan",
          "description": "Mostrar tipo de suscripci√≥n actual en UI de header y p√°gina de perfil",
          "files_to_modify": [
            "frontend/src/components/layout/Header.tsx",
            "frontend/src/pages/Profile.tsx",
            "frontend/src/components/subscription/SubscriptionStatus.tsx"
          ],
          "purpose": "Dar visibilidad al usuario de su estado de suscripci√≥n actual",
          "requirements": [
            "Header debe mostrar badge de Premium/Free seg√∫n suscripci√≥n",
            "Profile debe mostrar detalles completos de suscripci√≥n",
            "Componente SubscriptionStatus reutilizable",
            "Actualizaci√≥n en tiempo real al cambiar suscripci√≥n"
          ],
          "inputs": {
            "subscription": "Datos de suscripci√≥n desde useSubscription",
            "user": "Datos de usuario desde useAuth"
          },
          "outputs": {
            "ui_elements": {
              "badge": "Premium/Free badge en header",
              "status_card": "Card con detalles de suscripci√≥n en profile",
              "expiry_warning": "Advertencia si suscripci√≥n pr√≥xima a expirar"
            }
          },
          "test_cases": [
            {
              "name": "Header muestra badge Free para usuario sin suscripci√≥n",
              "expected": "Badge con texto 'Free' y color gris"
            },
            {
              "name": "Header muestra badge Premium para usuario con suscripci√≥n activa",
              "expected": "Badge con texto 'Premium' y color dorado"
            },
            {
              "name": "Profile muestra warning si suscripci√≥n expira en 3 d√≠as",
              "expected": "Componente de advertencia visible con CTA para renovar"
            }
          ],
          "implementation_steps": [
            "1. Crear SubscriptionStatus component reutilizable",
            "2. Integrar en Header con dise√±o responsive",
            "3. Agregar secci√≥n de suscripci√≥n en Profile page", 
            "4. Implementar l√≥gica de warning para pr√≥ximas expiraciones",
            "5. Tests de rendering para cada estado"
          ]
        }
      ]
    },
    {
      "phase": 2,
      "title": "Sanitizaci√≥n de Endpoints por Rol",
      "priority": "MEDIUM", 
      "estimated_time": "3-4 horas",
      "tasks": [
        {
          "id": "SAN-001",
          "title": "Aplicar Sanitizaci√≥n a Endpoint Articles",
          "description": "Implementar patr√≥n de attributes sanitizados en rutas de art√≠culos",
          "files_to_modify": [
            "backend/src/routes/articles.ts",
            "backend/src/models/Article.ts"
          ],
          "purpose": "Controlar qu√© campos de art√≠culos ve cada tipo de usuario",
          "requirements": [
            "Usuarios p√∫blicos (sin auth): solo campos b√°sicos",
            "Usuarios autenticados: campos adicionales",
            "Admin/Operator: todos los campos",
            "Mantener compatibilidad con frontend"
          ],
          "field_visibility": {
            "public": ["id", "title", "excerpt", "category", "status", "published_at", "author_id", "featured_image"],
            "authenticated": ["...public", "content", "tags", "venue_id", "view_count"],
            "admin": ["...all_fields"]
          },
          "endpoints_to_modify": [
            "GET /api/articles",
            "GET /api/articles/:id"
          ],
          "test_cases": [
            {
              "name": "Usuario sin auth ve solo campos p√∫blicos",
              "request": "GET /api/articles sin Authorization header",
              "expected": "Respuesta con solo campos p√∫blicos definidos"
            },
            {
              "name": "Usuario autenticado ve campos adicionales",
              "request": "GET /api/articles con JWT de user role",
              "expected": "Respuesta incluye content y tags"
            },
            {
              "name": "Admin ve todos los campos",
              "request": "GET /api/articles con JWT de admin role",
              "expected": "Respuesta completa sin restricciones"
            }
          ],
          "implementation_steps": [
            "1. Modificar middleware para detectar rol del usuario",
            "2. Implementar funci√≥n getArticleAttributes(userRole)",
            "3. Aplicar attributes en queries de Sequelize",
            "4. Escribir tests de integraci√≥n para cada rol"
          ]
        },
        {
          "id": "SAN-002",
          "title": "Aplicar Sanitizaci√≥n a Endpoint Events", 
          "description": "Controlar campos visibles de eventos seg√∫n rol de usuario",
          "files_to_modify": [
            "backend/src/routes/events.ts",
            "backend/src/models/Event.ts"
          ],
          "purpose": "Ocultar informaci√≥n operacional sensible de eventos a usuarios p√∫blicos",
          "field_visibility": {
            "public": ["id", "name", "scheduledDate", "status", "venueId"],
            "authenticated": ["...public", "totalFights", "completedFights"],
            "operator": ["...authenticated", "streamKey", "streamUrl", "operatorId"],
            "admin": ["...all_fields"]
          },
          "test_cases": [
            {
              "name": "Usuario p√∫blico no ve streamKey ni informaci√≥n operacional",
              "expected": "streamKey y streamUrl ausentes en respuesta"
            },
            {
              "name": "Operator ve sus campos operacionales",
              "expected": "streamKey y streamUrl incluidos para operators"
            }
          ],
          "implementation_steps": [
            "1. Crear funci√≥n getEventAttributes(userRole)", 
            "2. Aplicar en endpoints GET /api/events y GET /api/events/:id",
            "3. Tests para verificar campos por rol"
          ]
        },
        {
          "id": "SAN-003",
          "title": "Mantener Patr√≥n en Endpoint Venues",
          "description": "Verificar y documentar patr√≥n ya implementado en venues",
          "files_to_check": [
            "backend/src/routes/venues.ts"
          ],
          "purpose": "Asegurar consistencia del patr√≥n de sanitizaci√≥n",
          "requirements": [
            "Documentar patr√≥n actual",
            "Verificar que funcione correctamente",
            "Agregar tests faltantes"
          ],
          "test_cases": [
            {
              "name": "Verificar patr√≥n existente funciona",
              "expected": "Campos sanitizados seg√∫n rol actual"
            }
          ]
        }
      ]
    },
    {
      "phase": 3,
      "title": "Optimizaci√≥n de Payloads",
      "priority": "LOW",
      "estimated_time": "1-2 horas", 
      "tasks": [
        {
          "id": "OPT-001",
          "title": "Implementar Payload Lite para Articles",
          "description": "Crear m√©todo toPublicSummary() para listas vs toPublicJSON() para detalles",
          "files_to_modify": [
            "backend/src/models/Article.ts",
            "backend/src/routes/articles.ts"
          ],
          "purpose": "Optimizar transferencia de datos en listados de art√≠culos",
          "requirements": [
            "toPublicSummary(): campos m√≠nimos para listas",
            "toPublicJSON(): campos completos para detalle individual",
            "Aplicar en GET /api/articles (lista) vs GET /api/articles/:id (detalle)"
          ],
          "payload_comparison": {
            "summary": ["id", "title", "excerpt", "category", "status", "published_at", "author_name"],
            "detail": ["...summary", "content", "tags", "featured_image", "venue_name", "view_count"]
          },
          "test_cases": [
            {
              "name": "Lista de art√≠culos devuelve payload compacto",
              "endpoint": "GET /api/articles",
              "expected": "Array con objetos usando toPublicSummary()"
            },
            {
              "name": "Detalle de art√≠culo devuelve payload completo",
              "endpoint": "GET /api/articles/:id", 
              "expected": "Objeto usando toPublicJSON()"
            }
          ]
        }
      ]
    }
  ],

  "testing_strategy": {
    "approach": "test_driven_development",
    "test_types": {
      "unit": "M√©todos de modelos y utilidades",
      "integration": "Endpoints API completos",
      "e2e": "Flujos cr√≠ticos de suscripci√≥n"
    },
    "critical_test_scenarios": [
      "Transici√≥n usuario free -> premium -> expired",
      "Sanitizaci√≥n de campos por rol en todos los endpoints",
      "Consistencia entre useAuth y useSubscription"
    ],
    "test_files_to_create": [
      "backend/src/__tests__/routes/users.subscription.test.ts",
      "backend/src/__tests__/routes/articles.sanitization.test.ts", 
      "frontend/src/hooks/__tests__/useSubscription.test.ts",
      "frontend/src/components/__tests__/SubscriptionStatus.test.tsx"
    ]
  },

  "success_criteria": {
    "functional": [
      "Usuario ve tipo de plan correcto en header y profile",
      "useSubscription hook devuelve estado consistente", 
      "Endpoints sanitizan campos seg√∫n rol del usuario",
      "No hay inconsistencias entre diferentes fuentes de datos de suscripci√≥n"
    ],
    "technical": [
      "Todos los tests unitarios e integraci√≥n pasan",
      "No queries N+1 en endpoints modificados",
      "Respuestas API mantienen compatibilidad con frontend",
      "C√≥digo sigue convenciones establecidas del proyecto"
    ],
    "performance": [
      "Endpoints no aumentan tiempo de respuesta",
      "Frontend no hace requests redundantes de suscripci√≥n",
      "Payload de listas optimizado vs detalle individual"
    ]
  },

  "rollback_plan": {
    "risk_mitigation": [
      "Cada tarea tiene branch independiente",
      "Tests deben pasar antes de merge",
      "Backup de estructura actual antes de comenzar"
    ],
    "rollback_triggers": [
      "Tests fallan despu√©s de cambios",
      "Performance se degrada significativamente", 
      "Frontend deja de funcionar por cambios de API"
    ]
  }
}