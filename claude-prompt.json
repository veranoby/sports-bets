{
  "ðŸ”´_MANDATORY_START_HERE": {
    "purpose": "This prompt enforces critical protocols from brain/multi_ai_coordination_strategy.json to prevent analysis failures",
    "executor_model": "QWEN (qwen3-coder-plus-2025-09-23)",
    "role": "executor - backend SSE/WebSocket analysis",
    "execution_mode": "standard (full validation + evidence required)",
    "session_date": "2025-11-20",

    "step_1_read_before_working": [
      "âœ… brain/multi_ai_coordination_strategy.json (AUDIT_AND_ANALYSIS_METHODOLOGY_PROTOCOL: lines 147-280)",
      "âœ… brain/multi_ai_coordination_strategy.json (ROLE_AND_MODEL_AWARENESS_PROTOCOL: lines 103-126)",
      "âœ… brain/backlog.json (context on what Qwen already attempted)"
    ],

    "step_2_declare_yourself": "Before starting ANY work, output: 'Model: qwen3-coder-plus-2025-09-23 | Role: executor | Mode: standard | Task: Backend SSE/WebSocket Analysis'",

    "step_3_echo_back_task": {
      "requirement": "MANDATORY - Read this completely and echo back exact tasks",
      "format": "I will execute PHASES 1-4: [Phase 1 description] â†’ [Phase 2] â†’ [Phase 3] â†’ [Phase 4]. Generate final report in TEXT in this chat. Confirm Y/N?",
      "reference": "brain/multi_ai_coordination_strategy.json lines 79-101 (DIRECTOR_PLANNING_PROTOCOL)"
    },

    "step_4_activate_mcp": "Activate: --seq --sequential --c7 --context7 --token-efficient (required for code analysis and documentation)",

    "critical_warning": "âš ï¸ LESSON LEARNED: Last session, backlog.json documented BOTH 'SSE/WS files created' AND 'SSE/WS files don't exist' in same document. This was CONTRADICTION. You MUST verify with actual files, not trust assumptions."
  },

  "ðŸ”´_AUDIT_AND_ANALYSIS_METHODOLOGY_PROTOCOL": {
    "severity": "CRITICAL - Read brain/multi_ai_coordination_strategy.json lines 147-280 BEFORE starting work",
    "applicability": "ALL phases of this analysis task",

    "core_principle": "Absence of finding â‰  absence of existence. You must use BIDIRECTIONAL verification.",

    "rule_1_bidirectional_search": {
      "description": "For SSE/WebSocket analysis, search BOTH directions",
      "direction_A_to_B": [
        "Search: 'Are documented SSE endpoints actually implemented in code?'",
        "Files: grep backend/src/routes/*.ts for 'SSE', 'streaming', 'EventSource'",
        "Files: grep backend/src/*.ts for 'EventSource', 'sse', 'connection'",
        "Verify: Each documented endpoint has actual function implementation"
      ],
      "direction_B_to_A": [
        "Search: 'Are implemented SSE features documented in brain files?'",
        "Files: Read actual backend code (useSSEConnection.ts, streaming-monitoring.ts, etc.)",
        "List: Every EventSource, addEventListener, connection management code",
        "Compare against: brain/api_endpoints_reference.json to find UNDOCUMENTED implementations"
      ],
      "enforcement": "REPORT BOTH DIRECTIONS explicitly. 'Found 3 issues direction Aâ†’B. Found 2 issues direction Bâ†’A. Total: 5 discrepancies.'"
    },

    "rule_2_tool_validation": {
      "trigger_scenarios": [
        "âŒ Grep/search returns empty result â†’ VERIFY with direct Read tool",
        "âŒ Command returns 0 matches â†’ CONFIRM with alternative search method",
        "âŒ Expected file doesn't appear in search â†’ Read directory with ls/Glob to confirm file exists"
      ],
      "protocol_when_search_fails": [
        "Step 1: Acknowledge tool may have failed (syntax, path issue, permissions)",
        "Step 2: Switch to direct method (Read file, Glob search, manual inspection)",
        "Step 3: Document which tool failed and why",
        "Step 4: Use validated method for remaining work"
      ],
      "example_if_you_find_nothing": "If grep shows 'No SSE files found', do NOT conclude they don't exist. Instead: (1) ls -la frontend/src/hooks/ to list what's there, (2) Read specific files mentioned in backlog.json, (3) If files DON'T exist after Read attempt, then report 'File not found'."
    },

    "rule_3_systematic_coverage": {
      "checklist": [
        "List ALL files mentioned in analysis scope (from task definition)",
        "Create explicit verification checklist (not mental list)",
        "Check off items as VERIFIED (not assumed)",
        "Report 'verified present' AND 'verified absent' - not just missing findings"
      ],
      "scope_for_this_task": [
        "â–¡ backend/src/routes/streaming-monitoring.ts (endpoint implementation)",
        "â–¡ frontend/src/hooks/useSSEConnection.ts (hook lifecycle)",
        "â–¡ backend/src/contexts/WebSocketContext.tsx (if exists - verify first)",
        "â–¡ frontend/src/pages/admin/OptimizedStreamingMonitor.tsx (consumer code)",
        "â–¡ Any other SSE/WS files (grep before concluding scope)"
      ],
      "enforcement": "For each file: Either '[FILE EXISTS: Read completed]' OR '[FILE NOT FOUND: Verified with Glob/ls]'. No assumptions."
    },

    "rule_4_direct_inspection": {
      "trigger": "ALWAYS when: (1) Tool returns unexpected result, (2) Critical finding needs confirmation, (3) Contradiction detected",
      "method": "Use Read tool with offset/limit to manually inspect actual code",
      "example": "If you grep for 'EventSource' and find nothing, Read frontend/src/hooks/useSSEConnection.ts directly to check if it uses EventSource at all. Verify manually."
    },

    "rule_5_explicit_assumptions": {
      "process": [
        "List assumptions being made (e.g., 'Assuming all SSE files are in hooks/ directory')",
        "Validate EACH assumption explicitly (e.g., 'Verified: grep -r shows no other SSE implementations')",
        "Document validated assumptions in final report"
      ],
      "bad_example": "âŒ 'SSE/WS system doesn't exist because I didn't find files'",
      "good_example": "âœ… 'Searched: grep -r \"EventSource\" backend/src â†’ 0 results. Searched: grep -r \"EventSource\" frontend/src â†’ 3 files. Assumption: EventSource implementation exists in frontend, not backend. VALIDATED: backend uses polling instead.'"
    }
  },

  "ðŸ”´_VERIFICATION_WORKFLOW_BEFORE_EACH_PHASE": {
    "checkpoint_protocol": "Before starting EACH phase, run verification commands. Do NOT assume previous session's findings.",

    "verify_files_exist": {
      "command_1": "ls -la backend/src/routes/streaming-monitoring.ts && echo 'EXISTS' || echo 'NOT_FOUND'",
      "command_2": "ls -la frontend/src/hooks/useSSEConnection.ts && echo 'EXISTS' || echo 'NOT_FOUND'",
      "command_3": "find backend/src -type f -name '*sse*' -o -name '*websocket*' -o -name '*stream*' | head -20",
      "command_4": "find frontend/src -type f -name '*SSE*' -o -name '*sse*' | head -20",
      "output": "Report actual file list, not assumptions. Format: 'âœ… VERIFIED: Files exist: [list] | âŒ NOT_FOUND: [list]'"
    },

    "verify_previous_claims": {
      "backlog_states": "backlog.json claims: 'UNIFIED_STREAMING_MONITORING_IMPLEMENTATION_COMPLETED' with 'frontend/src/hooks/useSSEConnection.ts' created on 2025-11-19",
      "your_job": "Do NOT trust this. Verify: (1) Does file exist NOW? (2) Does it contain SSE logic? (3) Are the implementations in the file actual code or placeholders?",
      "if_contradiction_found": "STOP immediately and report: 'CONTRADICTION DETECTED: backlog.json claims [X] but actual file state shows [Y]. Require clarification before proceeding.'"
    }
  },

  "=_PHASE_1_STATIC_CODE_ANALYSIS": {
    "objective": "Identify memory leak risks, overcall patterns, inefficiencies through VERIFIED code inspection",
    "estimated_time": "25 minutes",
    "critical_requirement": "For EVERY finding, include: file:line | code snippet | risk assessment",

    "step_1_verify_files_exist": {
      "action": "Before reading any file, verify it actually exists",
      "commands": [
        "Read backend/src/routes/streaming-monitoring.ts (offset 1, limit 50) - check if file exists and has content",
        "Read frontend/src/hooks/useSSEConnection.ts (offset 1, limit 50) - check if file exists and has content",
        "If either file: 'No such file', STOP and report which files are MISSING"
      ]
    },

    "step_2_read_backend_sse": {
      "file": "backend/src/routes/streaming-monitoring.ts",
      "focus_questions": [
        "Does endpoint properly close EventSource connections?",
        "Are event listeners removed on cleanup?",
        "Are there connection limits?",
        "Is there timeout mechanism for idle connections?",
        "Are connections potentially orphaned on network errors?",
        "Is memory properly freed?"
      ],
      "evidence_format": "For each issue found: 'backend/src/routes/streaming-monitoring.ts:LINE | code snippet | risk: HIGH/MEDIUM/LOW | reason: [why this is a problem]'"
    },

    "step_3_read_frontend_sse_hook": {
      "file": "frontend/src/hooks/useSSEConnection.ts",
      "focus_questions": [
        "Does cleanup function properly remove all EventSource listeners?",
        "Does cleanup close EventSource connection?",
        "Are there memory leaks from closure references?",
        "Does useEffect have proper cleanup return?",
        "Are event listeners accumulating on re-renders?",
        "Is EventSource properly closed on unmount?"
      ],
      "evidence_format": "For each issue: 'frontend/src/hooks/useSSEConnection.ts:LINE | code snippet | risk: HIGH/MEDIUM/LOW'"
    },

    "step_4_search_for_other_sse_files": {
      "command": "find backend/src frontend/src -type f \\( -name '*.ts' -o -name '*.tsx' \\) -exec grep -l 'EventSource\\|addEventListener.*SSE\\|.on.*streaming' {} \\;",
      "purpose": "Ensure you haven't missed any SSE implementations",
      "document": "List ALL files with SSE-related code, not just the ones in task definition"
    },

    "step_5_search_for_polling_remnants": {
      "concern": "Migration from pollingâ†’SSE may be incomplete",
      "search_for": "grep -r 'setInterval\\|setTimeout.*fetch\\|polling' backend/src frontend/src | grep -i 'stream\\|event\\|connection'",
      "purpose": "Find polling calls that should use SSE instead",
      "document": "If found: 'Polling found in [file:line] - should use SSE instead. Estimated savings: [...]'"
    },

    "validation_checkpoint": "Before moving to Phase 2, confirm: (1) All referenced files verified to exist, (2) Each issue has file:line evidence, (3) No contradictions between findings"
  },

  "=_PHASE_2_INSTRUMENTATION_PLANNING": {
    "objective": "Design monitoring strategy (PLANNING ONLY, no code changes)",
    "estimated_time": "20 minutes",
    "no_code_changes": "Identify WHAT to monitor, not implementation",

    "step_1_define_metrics": {
      "metrics_to_plan": [
        "Active connections count (real-time tracking)",
        "Average connection lifetime (seconds)",
        "Memory usage by SSE buffers (MB)",
        "Event frequency (events/sec)",
        "Reconnection attempts per client",
        "Orphaned connections detection",
        "Event listener count (should be bounded)"
      ],
      "format_per_metric": {
        "metric_name": "Active connections",
        "where_to_measure": "backend/src/routes/streaming-monitoring.ts - global counter or WeakMap",
        "expected_normal_range": "10-500 concurrent",
        "alert_threshold": ">1000 concurrent (indicates leak or abuse)",
        "unit": "count"
      }
    },

    "step_2_identify_instrumentation_points": {
      "backend": "Identify exact locations in code where to add counters/logging",
      "frontend": "Identify exact locations where to track connection quality"
    }
  },

  "=_PHASE_3_LOAD_TESTING_SCENARIOS": {
    "objective": "Document realistic test scenarios (DESIGN ONLY, no implementation)",
    "estimated_time": "15 minutes",
    "format_per_scenario": {
      "scenario_id": "A",
      "name": "Baseline",
      "parameters": "10 concurrent, 60s duration",
      "expected_outcome": "Stable memory, <10ms latency",
      "leaks_to_detect": "None expected - baseline reference",
      "rationale": "Establish normal behavior reference"
    }
  },

  "=_PHASE_4_OPTIMIZATION_RECOMMENDATIONS": {
    "objective": "Synthesize Phases 1-3 into prioritized optimization plan",
    "estimated_time": "20 minutes",
    "template_per_recommendation": {
      "issue_id": "1",
      "title": "Issue description",
      "file_location": "path:line",
      "root_cause": "Why this happens",
      "memory_impact": "HIGH|MEDIUM|LOW",
      "effort_hours": "Estimated effort",
      "monthly_savings_usd": "Cost reduction estimate",
      "recommendation": "Specific action",
      "risk_level": "LOW|MEDIUM|HIGH",
      "evidence_reference": "Phase 1 finding #X"
    }
  },

  "ðŸ”´_REPORTING_PROTOCOL": {
    "reporting_location": "TEXT response in this chat ONLY (do NOT create files)",
    "report_structure": [
      "Executive Summary (health assessment - 3 sentences)",
      "Verification Methodology Used (which protocols applied)",
      "Phase 1: Static Analysis Findings (with file:line evidence)",
      "Phase 2: Instrumentation Plan (metrics to track)",
      "Phase 3: Load Test Scenarios (6+ test cases)",
      "Phase 4: Optimization Roadmap (quick-wins â†’ long-term)",
      "Total Estimated Impact (cost savings if implemented)",
      "Verification Evidence (actual command outputs used)"
    ],

    "evidence_format": "file:line | code snippet | finding | risk_level",

    "CRITICAL_BEFORE_REPORTING": [
      "âœ… Have you run BIDIRECTIONAL verification? (direction Aâ†’B AND direction Bâ†’A)",
      "âœ… Did you validate tool outputs (if empty, used Read directly)?",
      "âœ… Did you verify assumption about file locations?",
      "âœ… Did you check for contradictions in your findings?",
      "âœ… Is every finding backed by actual file:line evidence?",
      "If ANY answer is 'no', STOP and re-verify before reporting"
    ]
  },

  "ðŸ”´_SESSION_SAFETY_CHECKLIST": {
    "checkpoint_every_20_minutes": {
      "commit_with_tag": "git add brain/backlog.json && git commit -m '[CHECKPOINT] SSE analysis - Phase X in progress'",
      "purpose": "Save progress in case context is lost",
      "time_0_min": "Declare role and read protocols âœ…",
      "time_20_min": "Complete Phase 1, verify findings, checkpoint âœ…",
      "time_40_min": "Complete Phase 2, create instrumentation plan, checkpoint âœ…",
      "time_60_min": "Complete Phase 3, design test scenarios, checkpoint âœ…",
      "time_80_min": "Complete Phase 4, create recommendations, prepare report âœ…"
    },

    "red_flags_STOP_AND_REPORT": [
      "ðŸš¨ Finding 'no SSE files' but backlog.json claims they exist - STOP and verify with Read",
      "ðŸš¨ Tool returns unexpected result - STOP and validate with different method",
      "ðŸš¨ Contradiction between your findings - STOP and investigate root cause",
      "ðŸš¨ Session approaching 70 min - STOP and create handoff note",
      "ðŸš¨ Memory concerns about implementation - STOP and ask user to verify system state"
    ],

    "if_you_must_stop": {
      "format": "[SESSION_PAUSED] REASON: [why you stopped] | PROGRESS: [what's done] | NEXT: [what remains] | BLOCKER: [if applicable]",
      "example": "[SESSION_PAUSED] REASON: Found contradiction between backlog.json claims and actual file state | PROGRESS: Phase 1 partially completed, found 3 issues | NEXT: Verify files exist with Read tool before continuing Phase 1 | BLOCKER: Need clarification if useSSEConnection.ts actually exists"
    }
  },

  "=_FINAL_VALIDATION_BEFORE_REPORT": {
    "self_check_list": [
      "âœ… Task echo back was explicit and confirmed",
      "âœ… Bidirectional verification performed (Aâ†’B and Bâ†’A documented)",
      "âœ… Tool validation performed (empty results double-checked)",
      "âœ… All assumptions explicitly listed and validated",
      "âœ… Every finding has file:line evidence (no vague claims)",
      "âœ… Contradiction detection performed (checked if findings conflict)",
      "âœ… Report structure follows prescribed format",
      "âœ… Evidence includes actual command outputs (not simulated)",
      "âœ… Verification methodology is transparent"
    ],

    "if_any_item_unchecked": "DO NOT REPORT. Return to that phase and complete the verification. Better to take more time than report incomplete analysis."
  }
}
