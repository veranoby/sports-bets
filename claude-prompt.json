{
  "metadata": {
    "created": "2025-09-11",
    "version": "3.0-performance-optimizations",
    "purpose": "Backend performance optimizations for 1000+ user scaling",
    "priority": "P0 CRITICAL",
    "estimated_completion_time": "3-4 hours",
    "brain_reference": "/home/veranoby/sports-bets/brain/backlog.json",
    "target_performance": "Support 500+ concurrent users without degradation"
  },
  
  "context": {
    "current_situation": {
      "database_issues": "Duplicate constraints causing INSERT/UPDATE performance degradation",
      "scaling_target": "1000 users, 8 events/month, 4 hours each = 32k hours streaming",
      "concurrent_load": "500+ simultaneous users during peak events",
      "current_bottlenecks": ["Unlimited database connections", "No query performance monitoring", "Inefficient EventService queries", "Unmanaged WebSocket connections"]
    },
    "database_cleanup_status": "P0 CRITICAL - Execute SQL cleanup in Neon.tech editor FIRST",
    "architecture_confirmed": "Hybrid SSE (admin) + WebSocket (betting minimal) + Bunny.net CDN"
  },

  "implementation_phases": {
    "phase_1_database_connection_optimization": {
      "priority": "P0 CRITICAL",
      "description": "Implement connection pooling to prevent database overload",
      "files_to_modify": ["/home/veranoby/sports-bets/backend/src/config/database.ts"],
      "current_problem": "Unlimited connections will crash with 100+ concurrent users",
      "target_solution": "Max 20 connections with proper pooling and timeouts"
    },
    "phase_2_performance_monitoring": {
      "priority": "P0 CRITICAL", 
      "description": "Add middleware to track query performance and bottlenecks",
      "files_to_create": ["/home/veranoby/sports-bets/backend/src/middleware/performanceMonitoring.ts"],
      "target_solution": "Track queries >200ms, alert on >500ms, log slow operations"
    },
    "phase_3_service_optimization": {
      "priority": "P0 CRITICAL",
      "description": "Optimize EventService with eager loading and query reduction", 
      "files_to_modify": ["/home/veranoby/sports-bets/backend/src/services/eventService.ts"],
      "current_problem": "N+1 query problems loading events with venues/fights",
      "target_solution": "Single queries with includes, proper pagination"
    },
    "phase_4_websocket_management": {
      "priority": "P1",
      "description": "Add connection pooling and cleanup for WebSocket betting system",
      "files_to_modify": ["/home/veranoby/sports-bets/backend/src/sockets/bettingSocket.ts"],
      "target_solution": "Max 100 active connections, auto-cleanup inactive clients"
    }
  },

  "specific_implementation_instructions": {
    "database_connection_pooling": {
      "file": "/home/veranoby/sports-bets/backend/src/config/database.ts",
      "current_code_problem": "Sequelize connection without limits",
      "exact_implementation": {
        "add_after_line": "const sequelize = new Sequelize(DATABASE_URL, {",
        "insert_code": "  pool: {\n    max: 20,        // Maximum connections in pool\n    min: 5,         // Minimum connections to maintain\n    acquire: 30000, // Maximum time (ms) to wait for connection\n    idle: 10000,    // Maximum time (ms) connection can be idle\n    evict: 1000     // Run eviction every 1 second\n  },\n  logging: process.env.NODE_ENV === 'development' ? console.log : false,",
        "reasoning": "Prevents connection exhaustion under high load, maintains baseline connections for performance"
      }
    },
    
    "performance_monitoring_middleware": {
      "file": "/home/veranoby/sports-bets/backend/src/middleware/performanceMonitoring.ts",
      "create_new_file": true,
      "complete_implementation": "import { Request, Response, NextFunction } from 'express';\nimport { performance } from 'perf_hooks';\n\n// Track slow queries and performance metrics\nconst queryMetrics = new Map<string, {count: number, totalTime: number, slowQueries: number}>();\n\nexport const performanceMonitoring = (req: Request, res: Response, next: NextFunction) => {\n  const startTime = performance.now();\n  const originalUrl = req.originalUrl;\n  \n  // Hook into response finish to calculate total time\n  res.on('finish', () => {\n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    \n    // Track metrics by route\n    const metrics = queryMetrics.get(originalUrl) || {count: 0, totalTime: 0, slowQueries: 0};\n    metrics.count++;\n    metrics.totalTime += duration;\n    \n    // Flag slow queries (>200ms)\n    if (duration > 200) {\n      metrics.slowQueries++;\n      console.warn(`âš ï¸ Slow query detected: ${originalUrl} took ${duration.toFixed(2)}ms`);\n    }\n    \n    // Alert on very slow queries (>500ms)\n    if (duration > 500) {\n      console.error(`ðŸš¨ CRITICAL: Very slow query: ${originalUrl} took ${duration.toFixed(2)}ms`);\n    }\n    \n    queryMetrics.set(originalUrl, metrics);\n    \n    // Add performance headers for monitoring\n    res.set('X-Response-Time', `${duration.toFixed(2)}ms`);\n  });\n  \n  next();\n};\n\n// Export metrics for admin monitoring\nexport const getPerformanceMetrics = () => {\n  const metrics: any[] = [];\n  queryMetrics.forEach((data, route) => {\n    metrics.push({\n      route,\n      avgTime: data.totalTime / data.count,\n      totalRequests: data.count,\n      slowQueries: data.slowQueries,\n      slowQueryPercentage: ((data.slowQueries / data.count) * 100).toFixed(2)\n    });\n  });\n  return metrics.sort((a, b) => b.avgTime - a.avgTime);\n};",
      "integration_point": "Add to main app.ts: app.use(performanceMonitoring);"
    },

    "event_service_optimization": {
      "file": "/home/veranoby/sports-bets/backend/src/services/eventService.ts",
      "specific_optimizations": [
        {
          "method": "getAllEvents",
          "current_problem": "Separate queries for venue, fights, operator data",
          "optimization": "Single query with eager loading includes",
          "find_and_replace": {
            "find": "Event.findAll({",
            "replace": "Event.findAll({\n  include: [\n    { model: Venue, as: 'venue', attributes: ['id', 'name', 'location'] },\n    { model: User, as: 'operator', attributes: ['id', 'username'] },\n    { model: User, as: 'creator', attributes: ['id', 'username'] },\n    { model: Fight, as: 'fights', attributes: ['id', 'number', 'status', 'red_corner', 'blue_corner'] }\n  ],"
          }
        },
        {
          "method": "getEventById", 
          "current_problem": "Multiple database hits for related data",
          "optimization": "Single query with full includes",
          "find_and_replace": {
            "find": "Event.findByPk(eventId",
            "replace": "Event.findByPk(eventId, {\n  include: [\n    { model: Venue, as: 'venue' },\n    { model: User, as: 'operator', attributes: ['id', 'username', 'email'] },\n    { model: User, as: 'creator', attributes: ['id', 'username', 'email'] },\n    { \n      model: Fight, \n      as: 'fights',\n      include: [{ model: Bet, as: 'bets', attributes: ['id', 'amount', 'status'] }]\n    }\n  ]"
          }
        }
      ],
      "add_pagination_method": "export const getEventsPaginated = async (page: number = 1, limit: number = 20, filters?: any) => {\n  const offset = (page - 1) * limit;\n  return Event.findAndCountAll({\n    offset,\n    limit,\n    include: [/* same includes as above */],\n    where: filters || {},\n    order: [['scheduled_date', 'DESC']]\n  });\n};"
    },

    "websocket_connection_management": {
      "file": "/home/veranoby/sports-bets/backend/src/sockets/bettingSocket.ts",
      "add_connection_registry": {
        "add_at_top": "// WebSocket connection management\nconst activeConnections = new Map<string, { socket: any, lastActivity: Date, userId?: string }>();\nconst MAX_CONNECTIONS = 100;\nconst CLEANUP_INTERVAL = 5 * 60 * 1000; // 5 minutes",
        "add_connection_tracking": "// Track new connections\nio.on('connection', (socket) => {\n  const connectionId = socket.id;\n  \n  // Check connection limit\n  if (activeConnections.size >= MAX_CONNECTIONS) {\n    console.warn(`ðŸš¨ WebSocket connection limit reached: ${activeConnections.size}`);\n    socket.emit('error', { message: 'Server capacity reached, please try again later' });\n    socket.disconnect();\n    return;\n  }\n  \n  // Register connection\n  activeConnections.set(connectionId, {\n    socket,\n    lastActivity: new Date(),\n    userId: undefined\n  });\n  \n  console.log(`âœ… WebSocket connected: ${connectionId} (Total: ${activeConnections.size})`);\n  \n  // Update last activity on any event\n  socket.onAny(() => {\n    const conn = activeConnections.get(connectionId);\n    if (conn) {\n      conn.lastActivity = new Date();\n    }\n  });\n  \n  // Cleanup on disconnect\n  socket.on('disconnect', () => {\n    activeConnections.delete(connectionId);\n    console.log(`âŒ WebSocket disconnected: ${connectionId} (Total: ${activeConnections.size})`);\n  });",
        "add_cleanup_interval": "// Cleanup inactive connections every 5 minutes\nsetInterval(() => {\n  const now = new Date();\n  let cleanedUp = 0;\n  \n  activeConnections.forEach((conn, connectionId) => {\n    const inactiveTime = now.getTime() - conn.lastActivity.getTime();\n    if (inactiveTime > 10 * 60 * 1000) { // 10 minutes inactive\n      conn.socket.disconnect();\n      activeConnections.delete(connectionId);\n      cleanedUp++;\n    }\n  });\n  \n  if (cleanedUp > 0) {\n    console.log(`ðŸ§¹ Cleaned up ${cleanedUp} inactive WebSocket connections`);\n  }\n}, CLEANUP_INTERVAL);"
      }
    }
  },

  "testing_validation": {
    "performance_testing": [
      "Test with 50+ concurrent users hitting event endpoints",
      "Monitor query times in performance middleware logs", 
      "Verify connection pool doesn't exceed 20 connections",
      "Test WebSocket cleanup with multiple connections"
    ],
    "database_verification": [
      "Check pg_stat_activity for connection count during load",
      "Monitor slow query log for queries >200ms",
      "Verify no duplicate constraints remain after cleanup"
    ],
    "success_criteria": [
      "Event loading <200ms with full includes",
      "Database connections stable under load",
      "WebSocket connections auto-cleanup working",
      "No duplicate constraint errors in logs"
    ]
  },

  "integration_checklist": [
    "âœ… Execute SQL cleanup in Neon.tech editor FIRST",
    "â³ Implement database.ts connection pooling",
    "â³ Add performanceMonitoring.ts middleware",
    "â³ Optimize eventService.ts queries", 
    "â³ Add WebSocket connection management",
    "â³ Test with simulated high load",
    "â³ Monitor performance metrics in production"
  ],

  "deployment_notes": {
    "environment_variables": {
      "NODE_ENV": "production (disables query logging)",
      "DATABASE_MAX_CONNECTIONS": "20",
      "WEBSOCKET_MAX_CONNECTIONS": "100"
    },
    "monitoring_endpoints": [
      "GET /api/admin/performance-metrics (requires admin auth)",
      "GET /api/admin/database-stats (connection pool status)"
    ],
    "alerts_to_setup": [
      "Query times >500ms consistently",
      "Database connection pool exhaustion", 
      "WebSocket connection limit reached"
    ]
  }
}