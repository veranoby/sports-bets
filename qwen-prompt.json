{
  "DIRECTOR_ANALYSIS": {
    "task_title": "Fix EventDetail.tsx - Event/Stream State Logic + UI Rendering + HLS Player Issues + Real-time Architecture Audit",
    "coordinator": "Claude Sonnet 4.5 (Director)",
    "executor_target": "Qwen 3 Coder+",
    "execution_mode": "STANDARD",
    "prepared_date": "2025-12-09",
    "protocols_applied": [
      "DIRECTOR_PLANNING_PROTOCOL (brain/multi_ai_coordination_strategy.json:83-105)",
      "PROTOCOL_EXECUTION_DISCIPLINE (brain/multi_ai_coordination_strategy.json:1067-1149)"
    ]
  },

  "PRE_QWEN_ANALYSIS": {
    "eventdetail_status_changes": {
      "finding": "NO RECENT CHANGES BY QWEN",
      "evidence": "git log EventDetail.tsx shows last modification 9a101e70 (Gemini cleanup)",
      "impact": "Fight status changes (FightsControlTab) work correctly. Event status changes (StatusChanger) have original issue: missing refetch post-action",
      "recommendation": "Proceed with Task 3 in task list"
    },
    "liveevent_websocket_architecture": {
      "finding": "MISMATCH vs SDD SPECIFICATION",
      "sdd_spec": "brain/sdd_system.json:20-36 - WebSocket ONLY for PAGO/DOY proposals (3-min timeout bidirectional). SSE for all other real-time updates",
      "current_implementation": [
        "Line 596-607: useWebSocketListener('fight_updated') - WRONG (should be SSE)",
        "Line 609-620: useWebSocketListener('bet_created') - WRONG (should be SSE)",
        "Line 622-633: useWebSocketListener('event_updated') - CORRECT (bidirectional state change)"
      ],
      "recommendation": "Add Tasks 6-7 to refactor WebSocket/SSE architecture per SDD"
    },
    "liveeventswidget_status": {
      "finding": "ARCHITECTURE CORRECT",
      "evidence": "Line 113-118: WebSocket listener for 'event_started' → fetchEvents(). Proper single-listener pattern",
      "recommendation": "Add Task 7 for optional memory leak verification"
    }
  },

  "SCOPE": {
    "task_count": 7,
    "estimated_complexity": "HIGH",
    "affected_systems": ["Frontend state sync", "Event/Stream state machine", "Real-time architecture", "WebSocket/SSE coordination"],
    "session_time_estimate": "50-75 minutes (may need 2 sessions)",
    "checkpoint_protocol": "CRITICAL: 15-min checkpoints with git commits tagged [CHECKPOINT]"
  },

  "EXECUTOR_TASK_LIST": [
    {
      "task_id": 1,
      "title": "Backend Architecture Investigation",
      "description": "Audit backend streaming endpoints to understand event/stream lifecycle",
      "files_to_read": [
        "backend/routes/events.ts (search /stream/start, /stream/stop)",
        "backend/routes/streaming.ts (search /pause, /resume)",
        "backend/services/streamingService.ts (implementation details)",
        "backend/types/Event.ts (Event.streamStatus field definition)"
      ],
      "evidence_required": [
        "Endpoint mapping: /events/:id/stream/start → backend function → DB changes",
        "State diagram: offline → connecting → connected → paused → disconnected",
        "OBS integration flow: how stream key is generated/used"
      ],
      "success_criteria": "Clear endpoint documentation with state transitions"
    },

    {
      "task_id": 2,
      "title": "Define Event/Stream State Machine in PRD",
      "description": "Document all valid combinations of event.status + event.streamStatus + UI messaging",
      "files_to_modify": ["brain/prd_system.json"],
      "changes_required": [
        "Add new section: 'event_streaming_state_machine'",
        "Document 12 combinations (3 event statuses × 4 stream statuses)",
        "Example: status='active' + streamStatus='offline' → UI: 'Evento iniciado - Esperando inicio de transmisión'"
      ],
      "success_criteria": "All state combinations documented with UI messaging"
    },

    {
      "task_id": 3,
      "title": "Fix EventDetail.tsx State Sync - StatusChanger Post-Action Refetch",
      "description": "After user changes event status via StatusChanger, frontend should immediately reflect change",
      "files_to_modify": ["frontend/src/components/admin/events/EventDetail.tsx"],
      "changes_required": [
        "Line 133-146 handleEventActionLocal(): Add fetchEventDetail() call after onEventAction succeeds",
        "Add SSE listener for 'event_status_changed' event to update eventDetailData.event in real-time",
        "Test workflow: Change status selector → UI updates immediately (no refresh needed)"
      ],
      "evidence_required": [
        "git diff lines 133-146",
        "Before/after screenshot: status change visible immediately",
        "grep output: SSE listener code"
      ],
      "success_criteria": "Status change reflects in UI without page refresh"
    },

    {
      "task_id": 4,
      "title": "Fix HLSPlayer Rendering Condition",
      "description": "HLSPlayer crashes with 'manifestParsingError' when status=active but streamStatus=offline. Fix conditional rendering.",
      "files_to_modify": ["frontend/src/components/admin/events/EventDetail.tsx"],
      "changes_required": [
        "Line 331: Replace 'if (eventDetailData.event.streamUrl)' with 'if (eventDetailData.event.streamUrl && eventDetailData.event.streamStatus === \"connected\")'",
        "Add fallback UI when streamStatus !== 'connected': Icon + text 'Streaming offline'",
        "Test: Set status=active, streamStatus=offline → verify no HLS.js error, placeholder shows instead"
      ],
      "evidence_required": [
        "git diff lines 331-338",
        "Console output: no HLS.js fatal error in browser dev tools"
      ],
      "success_criteria": "No HLS.js errors when stream is offline"
    },

    {
      "task_id": 5,
      "title": "Add Streaming Control Button Validation",
      "description": "Pause/Resume/Stop buttons should validate streamStatus before executing",
      "files_to_modify": ["frontend/src/components/admin/events/EventDetail.tsx"],
      "changes_required": [
        "Lines 462-467 (pause button): Add disabled state if streamStatus !== 'connected'",
        "Lines 502-505 (resume button): Add disabled state if streamStatus !== 'paused'",
        "Add tooltip: 'Stream not active' when buttons disabled",
        "Add 'OBS Connection Status: Connected/Disconnected' indicator near controls"
      ],
      "evidence_required": [
        "git diff showing button disabled logic",
        "Screenshot: buttons disabled when appropriate"
      ],
      "success_criteria": "Buttons properly disabled based on stream state"
    },

    {
      "task_id": 6,
      "title": "Refactor LiveEvent.tsx Real-Time Architecture (WebSocket → SSE per SDD)",
      "description": "LiveEvent.tsx uses WebSocket for fight_updated + bet_created. SDD specifies WebSocket ONLY for PAGO/DOY proposals. Refactor to SSE.",
      "files_to_read": [
        "brain/sdd_system.json:20-36 (real_time_architecture specification)",
        "frontend/src/pages/user/LiveEvent.tsx:596-633 (current WebSocket listeners)"
      ],
      "files_to_modify": ["frontend/src/pages/user/LiveEvent.tsx"],
      "changes_required": [
        "Line 596-607: Either replace useWebSocketListener('fight_updated') with SSE listener, OR add code comment: 'TODO: Migrate to SSE per SDD (brain/sdd_system.json:30-31)'",
        "Line 609-620: Same as above for bet_created (lower priority than fight_updated)",
        "Line 622-633: KEEP useWebSocketListener('event_updated') - this is correct for state changes",
        "Add header comment: 'Real-time architecture per SDD (brain/sdd_system.json:20-36): SSE for reads, WebSocket for bidirectional (PAGO/DOY only)'"
      ],
      "evidence_required": [
        "git diff showing listener changes",
        "Code comment explaining why each listener uses SSE vs WebSocket",
        "Test: Fight updates and bet creation still work in real-time"
      ],
      "success_criteria": "Real-time updates follow SDD architecture (SSE-first)"
    },

    {
      "task_id": 7,
      "title": "Audit LiveEventsWidget.tsx Memory Leaks (Optional)",
      "description": "Verify that WebSocket listener cleanup prevents memory leaks",
      "files_to_read": [
        "frontend/src/components/user/LiveEventsWidget.tsx:113-118",
        "frontend/src/hooks/useWebSocket.ts (cleanup logic)"
      ],
      "success_criteria": [
        "Confirm useWebSocketListener cleanup on component unmount",
        "Verify no duplicate listeners on re-renders",
        "Document findings"
      ]
    }
  ],

  "CRITICAL_PROTOCOLS_FOR_EXECUTOR": {
    "session_initialization": [
      "Step 1: Declare model (Qwen 3 Coder+) + role (Executor) + mode (STANDARD)",
      "Step 2: Echo back this task list for user confirmation",
      "Step 3: Set 15-min checkpoint timer"
    ],
    "execution_discipline": [
      "DO NOT assume backend behavior - read actual code",
      "DO NOT skip TypeScript validation: npx tsc --noEmit after changes",
      "MUST cite line numbers + file paths for all claims",
      "MUST provide git diff output for code changes"
    ],
    "checkpoint_protocol": [
      "Every 15 min: git add && git commit -m '[CHECKPOINT] Task X progress'",
      "Upon session end: Write handoff note to brain/backlog.json with git commit hashes"
    ],
    "reporting_location": "brain/backlog.json with 'git_commits' field containing actual hashes"
  },

  "VALIDATION_GATES_MANDATORY": [
    "Gate 1: TypeScript - npx tsc --noEmit (0 errors)",
    "Gate 2: File verification - Read actual .tsx files, confirm changes visible",
    "Gate 3: Git validation - git diff --name-only shows ONLY approved files",
    "Gate 4: Evidence - Before/after test results documented"
  ],

  "KNOWN_RISKS": {
    "risk_1": "Backend investigation may reveal API design gaps",
    "mitigation_1": "Document findings - may require separate backend task",
    "risk_2": "Session length may exceed 40 minutes",
    "mitigation_2": "Split into 2 sessions if needed: Investigation, then Implementation"
  }
}
